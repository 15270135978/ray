<?xml version="1.0"?>
<effect version="1270" language="hlsl">
    <include name="sys:fx/math.fxml"/>
    <include name="sys:fx/sampler.fxml"/>
    <include name="sys:fx/lighting.fxml"/>
    <shader>
        <![CDATA[
            #define LIGHTINGMODEL_NORMAL         0
            #define LIGHTINGMODEL_TRANSMITTANCE  1

            #define MAX_FRACTIONAL_8_BIT        (255.0f / 256.0f)
            #define TWO_BITS_EXTRACTION_FACTOR  (3.0f + MAX_FRACTIONAL_8_BIT)

            struct MaterialParam
            {
                float3 normal;
                float3 albedo;
                float3 specular;
                float3 transmittance;
                float smoothness;
                float occlusion;
                int lightModel;
            };

            struct GbufferParam
            {
                float4 buffer1 : SV_Target0;
                float4 buffer2 : SV_Target1;
                float4 buffer3 : SV_Target2;
            };

            float3 EncodeFloatRGB(float v)
            {
                float3 enc = float3(256.0 * 256.0, 256.0, 1.0);
                enc = frac(v * enc);
                enc -= enc.xxy * float3(0.0, 1.0/256.0, 1.0/256.0);
                return enc;
            }

            float DecodeFloatRGB(float3 rgb)
            {
                return dot(rgb, float3(1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0));
            }

            float4 EncodeFloatRGBA(float v)
            {
                // http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/
                float4 enc = float4(1.0f, 255.0f, 65025.0f, 16581375.0f);
                enc = frac(v * enc);
                enc -= enc.yzww * float4(1 / 255.0f, 1 / 255.0f, 1 / 255.0f, 0);
                return enc;
            }

            float DecodeFloatRGBA(float4 rgba)
            {
               return dot(rgba, float4(1, 1 / 255.0f, 1 / 65025.0f, 1 / 16581375.0f));
            }

            float3 EncodeNormal(float3 normal)
            {
                // http://aras-p.info/texts/CompactNormalStorage.html
                float p = sqrt(-normal.z * 8 + 8);
                float2 enc = normal.xy / p + 0.5f;
                float2 enc255 = enc * 255;
                float2 residual = floor(frac(enc255) * 16);
                return float3(floor(enc255), residual.x * 16 + residual.y) / 255;
            }

            float3 DecodeNormal(float3 enc)
            {
                float nz = floor(enc.z * 255) / 16;
                enc.xy += float2(floor(nz) / 16, frac(nz)) / 255;
                float2 fenc = enc.xy * 4 - 2;
                float f = dot(fenc, fenc);
                float g = sqrt(1 - f / 4);
                float3 normal;
                normal.xy = fenc * g;
                normal.z = f / 2 - 1;
                return normal;
            }

            GbufferParam EncodeGbuffer(MaterialParam material)
            {
                // http://www.crytek.com/download/2014_03_25_CRYENGINE_GDC_Schultz.pdf
                GbufferParam gbuffer;
                gbuffer.buffer1.rgb = material.albedo;
                gbuffer.buffer1.w = material.occlusion;

                gbuffer.buffer2.xyz = EncodeNormal(material.normal);
                gbuffer.buffer2.w = material.smoothness;

                gbuffer.buffer3.rgb = rgb2ycbcr(material.specular);
                gbuffer.buffer3.w = 0;

                if (material.lightModel == LIGHTINGMODEL_TRANSMITTANCE)
                {
                    material.transmittance = rgb2ycbcr(material.transmittance);
                    gbuffer.buffer3.yz = material.transmittance.gb;
                    gbuffer.buffer3.w = material.transmittance.r * MAX_FRACTIONAL_8_BIT;
                }

                gbuffer.buffer3.w = ((float)material.lightModel + gbuffer.buffer3.w) / TWO_BITS_EXTRACTION_FACTOR;
                return gbuffer;
            }

            GbufferParam EncodeGbufferWithAlpha(MaterialParam material, float alphaDiffuse, float alphaNormals, float alphaSpecular)
            {
                GbufferParam gbuffer;
                gbuffer = EncodeGbuffer(material);
                gbuffer.buffer1.w = alphaDiffuse;
                gbuffer.buffer2.w = alphaNormals;
                gbuffer.buffer3.w = alphaSpecular;
                return gbuffer;
            }

            void DecodeGbuffer(float4 buffer1, float4 buffer2, float4 buffer3, out MaterialParam material)
            {
                material.lightModel = (int)floor(buffer3.w * TWO_BITS_EXTRACTION_FACTOR);

                material.albedo = buffer1.rgb;
                material.occlusion = buffer1.a;

                material.normal = DecodeNormal(buffer2.xyz);
                material.smoothness = buffer2.w;

                if (material.lightModel == LIGHTINGMODEL_TRANSMITTANCE)
                {
                    material.specular = buffer3.xxx;
                    material.transmittance = ycbcr2rgb(buffer3.wyz);
                }
                else
                {
                    material.specular = ycbcr2rgb(buffer3.xyz);
                    material.transmittance = 0;
                }
            }

            float3 DecodeDiffuse(texture2D mrt0, float2 coord)
            {
                return mrt0.Sample(PointClamp, coord).rgb;
            }

            float3 DecodeDiffuse(float4 mrt0)
            {
                return mrt0.rgb;
            }

            float3 DecodeGBufferNormal(float4 buffer2)
            {
                return DecodeNormal(buffer2.xyz);
            }

            float DecodeSpecular(float4 mrt0)
            {
                return mrt0.a;
            }

            float DecodeSmoothness(float4 mrt1)
            {
                return mrt1.w;
            }

            float3 restorePosition(texture2D texDepth, float4x4 matInverse, float2 coord)
            {
                float depth = texDepth.Sample(PointClamp, coord.xy).r;
                float4 result = mul(matInverse, float4(coord * 2.0 - 1.0, depth, 1.0));
                result /= result.w;
                return result.xyz;
            }

            float3 restorePosition(texture2D texDepthLinear, float4 projInfo, float2 coord)
            {
                float depth = texDepthLinear.Sample(PointClamp, coord).r;
                return float3(projInfo.xy * coord + projInfo.zw, 1.0) * depth;
            }

            float3 restorePosition(texture2D texDepthLinear, float2 coord, float3 viewdir)
            {
                float depth = texDepthLinear.Sample(PointClamp, coord).r;
                return viewdir * depth / viewdir.z;
            }

            float computeWeightBlendOIT(float linearDepth)
            {
                return clamp(0.03 / (1e-5 + pow(linearDepth, 4.0)), 1e-2, 3e3);
            }
        ]]>
    </shader>
 </effect>