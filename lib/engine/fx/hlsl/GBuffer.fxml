<?xml version="1.0"?>
<effect version="1270" language="hlsl">
    <include name="sys:fx/math.fxml"/>
    <include name="sys:fx/sampler.fxml"/>
    <include name="sys:fx/lighting.fxml"/>
    <shader>
        <![CDATA[
            #define LIGHTINGMODEL_NORMAL         0
            #define LIGHTINGMODEL_TRANSMITTANCE  1

            struct MaterialParam
            {
                float3 normal;
                float3 albedo;
                float3 specular;
                float3 transmittance;
                float smoothness;
                int lightModel;
            };

            struct GbufferParam
            {
                float4 buffer1 : SV_Target0;
                float4 buffer2 : SV_Target1;
                float4 buffer3 : SV_Target2;
            };

            float3 EncodeNormal(float3 normal)
            {
                float p = sqrt(-normal.z * 8 + 8);
                float2 enc = normal.xy / p + 0.5f;
                float2 enc255 = enc * 255;
                float2 residual = floor(frac(enc255) * 16);
                return float3(floor(enc255), residual.x * 16 + residual.y) / 255;
            }

            float3 DecodeNormal(float3 enc)
            {
                float nz = floor(enc.z * 255) / 16;
                enc.xy += float2(floor(nz) / 16, frac(nz)) / 255;
                float2 fenc = enc.xy * 4 - 2;
                float f = dot(fenc, fenc);
                float g = sqrt(1 - f / 4);
                float3 normal;
                normal.xy = fenc * g;
                normal.z = f / 2 - 1;
                return normal;
            }

            GbufferParam EncodeGbuffer(MaterialParam material)
            {
                GbufferParam gbuffer;
                gbuffer.buffer1 = float4(material.albedo, luminance(material.specular));
                gbuffer.buffer2 = float4(EncodeNormal(material.normal), material.smoothness);
                gbuffer.buffer3 = float4(material.transmittance, material.lightModel);
                return gbuffer;
            }

            MaterialParam DecodeGbuffer(float4 buffer1, float4 buffer2, float4 buffer3)
            {
                MaterialParam material;
                material.albedo = buffer1.rgb;
                material.specular = buffer1.a;
                material.normal = DecodeNormal(buffer2.xyz);
                material.smoothness = buffer2.w;
                material.transmittance = buffer3.rgb;
                material.lightModel = buffer3.w;
                return material;
            }

            float4 StoreGBufferRT0(float3 diffuse, float3 specular)
            {
                return float4(diffuse, luminance(specular));
            }

            float4 StoreGBufferRT0(float3 diffuse, float specular)
            {
                return float4(diffuse, specular);
            }

            float4 StoreGBufferRT1(float3 n, float smoothness)
            {
                return float4(EncodeNormal(n), smoothness);
            }

            float4 StoreGBufferRT2(float weight, float alpha)
            {
                return float4(float3(weight,weight,weight), alpha);
            }

            float4 StoreGBufferRT3(float3 transmittance, float profile)
            {
                return float4(transmittance, profile);
            }

            float3 restoreDiffuse(texture2D mrt0, float2 coord)
            {
                return mrt0.Sample(PointClamp, coord).rgb;
            }

            float3 restoreDiffuse(float4 mrt0)
            {
                return mrt0.rgb;
            }

            float restoreSpecular(float4 mrt0)
            {
                return mrt0.a;
            }

            float3 DecodeGBufferNormal(float4 buffer2)
            {
                return DecodeNormal(buffer2.xyz);
            }

            float restoreShininess(float4 mrt1)
            {
                return mrt1.w;
            }

            float3 restorePosition(texture2D texDepth, float4x4 matInverse, float2 coord)
            {
                float depth = texDepth.Sample(PointClamp, coord.xy).r;
                float4 result = mul(matInverse, float4(coord * 2.0 - 1.0, depth, 1.0));
                result /= result.w;
                return result.xyz;
            }

            float3 restorePosition(texture2D texDepthLinear, float4 projInfo, float2 coord)
            {
                float depth = texDepthLinear.Sample(PointClamp, coord).r;
                return float3(projInfo.xy * coord + projInfo.zw, 1.0) * depth;
            }

            float3 restorePosition(texture2D texDepthLinear, float2 coord, float3 viewdir)
            {
                float depth = texDepthLinear.Sample(PointClamp, coord).r;
                return viewdir * depth / viewdir.z;
            }

            float computeWeightBlendOIT(float linearDepth)
            {
                return clamp(0.03 / (1e-5 + pow(linearDepth, 4.0)), 1e-2, 3e3);
            }
        ]]>
    </shader>
 </effect>