<?xml version='1.0'?>
<effect language="hlsl">
    <include name="sys:fx/Gbuffer.fxml"/>
    <include name="sys:fx/inputlayout.fxml"/>
    <parameter name="texSource" type="texture2D" />
    <parameter name="texDepthLinear" type="texture2D" semantic="DepthLinearMap"/>
    <parameter name="blurFactor" type="float3"/>
    <shader name="vertex">
        <![CDATA[
        void PostProcessVS(
            in float4 Position : POSITION0,
            out float4 oTexcoord : TEXCOORD0,
            out float4 oPosition : SV_Position)
        {
            oPosition = Position;
            oTexcoord = PosToCoord(Position);
        }

        float3 GuassBlurPS(in float4 coord : TEXCOORD0) : SV_Target
        {
            const float offsets[6] = { 0.352, 0.719, 1.117, 1.579, 2.177, 3.213 };

            const float3 profileVarArr[2] =
            {
                float3( 3.3, 2.8, 1.4 ),  // marble
                float3( 3.3, 1.4, 1.1 )   // skin
            };

            const float4 profileSpikeRadArr[2] =
            {
                float4( 0.03, 0.03, 0.08, 8.0 ),  // marble
                float4( 0.015, 0.020, 0.025, 1.0) // skin
            };

            float4 colorM = texSource.Sample(PointClamp, coord.xy);
            float depthM = texDepthLinear.Sample(PointClamp, coord.xy).r;

            float radius = 0.0055 * profileSpikeRadArr[1].w;
            float2 finalStep = blurFactor.xy * radius / (depthM * blurFactor.z);

            float3 blurFalloff = -1.0f / (2 * profileVarArr[1]);

            float3 totalWeight = 1;
            float4 totalColor = colorM * 0.382f;

            [unroll]
            for (int i = 0; i < 6; i++)
            {
                float2 offset = coord.xy + offsets[i] / 5.5 * finalStep;

                float sampleDepth = texDepthLinear.Sample(PointClamp, offset).r;
                float3 sampleColor = texSource.Sample(PointClamp, offset).rgb;

                float depthDiff = abs(sampleDepth - depthM) * 1000 * blurFactor.z;

                float3 weight = exp((offsets[i] * offsets[i] + depthDiff * depthDiff) * blurFalloff);

                totalWeight += weight;
                totalColor.rgb += weight * sampleColor;
            }

            [unroll]
            for (int i = 0; i < 6; i++)
            {
                float2 offset = coord.xy - offsets[i] / 5.5 * finalStep;

                float sampleDepth = texDepthLinear.Sample(PointClamp, offset).r;
                float3 sampleColor = texSource.Sample(PointClamp, offset).rgb;

                float depthDiff = abs(sampleDepth - depthM) * 1000 * blurFactor.z;

                float3 weight = exp((offsets[i] * offsets[i] + depthDiff * depthDiff) * blurFalloff);

                totalWeight += weight;
                totalColor.rgb += weight * sampleColor;
            }

            return totalColor.rgb / totalWeight;
        }
        ]]>
    </shader>
    <technique name="blur">
        <pass name="p0">
            <state name="inputlayout" value="POS3F"/>

            <state name="vertex" value="PostProcessVS"/>
            <state name="fragment" value="GuassBlurPS"/>

            <state name="cullmode" value="none" />

            <state name="depthtest" value="false"/>
            <state name="depthwrite" value="false"/>
        </pass>
    </technique>
</effect>