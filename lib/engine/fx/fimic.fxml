<?xml version='1.0'?>
<effect version="1270" language="hlsl">
    <include name="sys:fx/math.fxml"/>
    <include name="sys:fx/sampler.fxml"/>
    <include name="sys:fx/inputlayout.fxml"/>
    <macro name="TONEMAP_LINEAR" value="0"/>
    <macro name="TONEMAP_EXPONENTIAL" value="1"/>
    <macro name="TONEMAP_EXPONENTIAL_HSV" value="2"/>
    <macro name="TONEMAP_REINHARD" value="3"/>
    <macro name="TONEMAP_FILMIC" value="4"/>
    <macro name="TONEMAP_UNCHARTED2" value="5"/>
    <macro name="TONEMAP_OPERATOR" value="TONEMAP_UNCHARTED2"/>
    <parameter name="texSource" type="texture2D" />
    <parameter name="texSourceSizeInv" type="float2" />
    <parameter name="texBloom" type="texture2D" />
    <parameter name="texLumAve" type="texture2D" />
    <parameter name="bloomThreshold" type="float" />
    <parameter name="bloomIntensity" type="float" />
    <parameter name="bloomOffset[10]" type="float[]" />
    <parameter name="bloomWeight[11]" type="float[]" />
    <parameter name="texSourceLevel" type="int"/>
    <parameter name="exposure" type="float" />
    <parameter name="delta" type="float" />
    <shader>
        <![CDATA[
            float3 Uncharted2Tonemap(float3 x)
            {
                const float A = 0.22; // Shoulder Strength
                const float B = 0.30; // Linear Strength
                const float C = 0.10; // Linear Angle
                const float D = 0.20; // Toe Strength
                const float E = 0.01; // Toe Numerator
                const float F = 0.30; // Toe Denominator E/F = Toe Angle
                const float W = 11.2; // Linear White Point Value
                return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;
            }

            float3 FilmicTonemap(float3 color, float exposure)
            {
                #if TONEMAP_OPERATOR == TONEMAP_LINEAR
                    return exposure * color;
                #elif TONEMAP_OPERATOR == TONEMAP_EXPONENTIAL
                    color = 1.0 - exp2(-exposure * color);
                    return color;
                #elif TONEMAP_OPERATOR == TONEMAP_EXPONENTIAL_HSV
                    color = rgb2hsv(color);
                    color.b = 1.0 - exp2(-exposure * color.b);
                    color = hsv2rgb(color);
                    return color;
                #elif TONEMAP_OPERATOR == TONEMAP_REINHARD
                    color = xyz2Yxy(rgb2xyz(color));
                    float L = color.r;
                    L *= exposure;
                    float LL = 1 + L / (burnout * burnout);
                    float L_d = L * LL / (1 + L);
                    color.r = L_d;
                    color = xyz2rgb(Yxy2xyz(color));
                    return color;
                #elif TONEMAP_OPERATOR == TONEMAP_FILMIC
                    color = 2 * Uncharted2Tonemap(exposure * color);
                    float3 whiteScale = 1.0f / Uncharted2Tonemap(11.2);
                    color *= whiteScale;
                    return color;
                #elif TONEMAP_OPERATOR == TONEMAP_UNCHARTED2
                    color = Uncharted2Tonemap(exposure * color);
                    float3 whiteScale = 1.0f / Uncharted2Tonemap(11.2);
                    color *= whiteScale;
                    return color;
                #else
                    return color;
                #endif
            }

            float3 ToneBlueShift(float3 color, float lum)
            {
                const float3 BLUE_SHIFT = float3(0.4f, 0.4f, 0.7f);
                return lerp(lum * BLUE_SHIFT, color, saturate(16.0f * lum));
            }

            float EyeAdaption(float lum)
            {
                return lerp(0.2f, lum, 0.5f);
            }

            float ToneExposure(float avgLum)
            {
                return 3 / (max(0.1f, 1 + 10 * EyeAdaption(avgLum)));
            }

            float CalcAdaptedLum(float adaptedLum, float lum, float delta)
            {
                return adaptedLum + (lum - adaptedLum) * (1.0f - pow(0.98f, 50 * delta));
            }

            float3 ToneMapping(float3 color, float aveLum, float exposure)
            {
                color += ToneBlueShift(color, luminance(color));
                color = FilmicTonemap(color, exposure * ToneExposure(aveLum));
                return color;
            }

            void PostProcessVS(
                in float4 Position : POSITION0,
                out float4 oTexcoord : TEXCOORD0,
                out float4 oPosition : SV_Position)
            {
                oPosition = Position;
                oTexcoord = PosToCoord(Position);
            }

            void SumLumVS(
                in float4 Position : POSITION0,
                out float4 oTexcoord0 : TEXCOORD0,
                out float4 oTexcoord1 : TEXCOORD1,
                out float4 oPosition : SV_Position)
            {
                oPosition = Position;
                oTexcoord0.xy = PosToCoord(Position.xy);
                oTexcoord0.zw = oTexcoord0.xy + float2(texSourceSizeInv.x, 0);
                oTexcoord1.xy = oTexcoord0.xy + texSourceSizeInv;
                oTexcoord1.zw = oTexcoord0.xy + float2(0, texSourceSizeInv.y);
            }

            float4 SumLumPS(in float4 coord0 : TEXCOORD0, in float4 coord1 : TEXCOORD1) : SV_Target0
            {
                float4 color = texSource.Sample(PointClamp, coord0.xy);
                color += texSource.Sample(PointClamp, coord0.zw);
                color += texSource.Sample(PointClamp, coord1.xy);
                color += texSource.Sample(PointClamp, coord1.zw);
                color *= 0.25;

                return color;
            }

            float SumLumLogPS(in float4 coord0 : TEXCOORD0, in float4 coord1 : TEXCOORD1) : SV_Target0
            {
                float4 color = texSource.Sample(PointClamp, coord0.xy);
                color += texSource.Sample(PointClamp, coord0.zw);
                color += texSource.Sample(PointClamp, coord1.xy);
                color += texSource.Sample(PointClamp, coord1.zw);
                color *= 0.25;

                const float epsilon = 0.01f;
                return log(max(epsilon, luminance(color)));
            }

            float AvgLuminancePS(in float4 coord0 : TEXCOORD0, in float4 coord1 : TEXCOORD1) : SV_Target0
            {
                float color = texSource.SampleLevel(PointClamp, coord0.xy, 8).r;
                float adaptedLum = texLumAve.Sample(PointClamp, float2(0,0)).r;
                return saturate(CalcAdaptedLum(adaptedLum, exp(color), delta));
            }

            float4 BloomPS(in float4 coord : TEXCOORD0) : SV_Target0
            {
                float4 color = texSource.Sample(PointClamp, coord.xy);
                return float4(max(0, (color.rgb - bloomThreshold) * bloomIntensity), color.a);
            }

            void BlurXVS(
                in float4 Position : POSITION0,
                out float4 oTexcoord0 : TEXCOORD0,
                out float4 oTexcoord1 : TEXCOORD1,
                out float4 oTexcoord2 : TEXCOORD2,
                out float4 oTexcoord3 : TEXCOORD3,
                out float4 oTexcoord4 : TEXCOORD4,
                out float4 oTexcoord5 : TEXCOORD5,
                out float4 oPosition : SV_Position)
            {
                oPosition = Position;
                oTexcoord0.xy = PosToCoord(Position.xy);
                oTexcoord1 = oTexcoord0.xyxy + float4(float2(bloomOffset[0], 0), float2(bloomOffset[1].x, 0)) * texSourceSizeInv.x;
                oTexcoord2 = oTexcoord0.xyxy + float4(float2(bloomOffset[2], 0), float2(bloomOffset[3].x, 0)) * texSourceSizeInv.x;
                oTexcoord3 = oTexcoord0.xyxy + float4(float2(bloomOffset[4], 0), float2(bloomOffset[5].x, 0)) * texSourceSizeInv.x;
                oTexcoord4 = oTexcoord0.xyxy + float4(float2(bloomOffset[6], 0), float2(bloomOffset[7].x, 0)) * texSourceSizeInv.x;
                oTexcoord5 = oTexcoord0.xyxy + float4(float2(bloomOffset[8], 0), float2(bloomOffset[9].x, 0)) * texSourceSizeInv.x;
            }

            void BlurYVS(
                in float4 Position : POSITION0,
                out float4 oTexcoord0 : TEXCOORD0,
                out float4 oTexcoord1 : TEXCOORD1,
                out float4 oTexcoord2 : TEXCOORD2,
                out float4 oTexcoord3 : TEXCOORD3,
                out float4 oTexcoord4 : TEXCOORD4,
                out float4 oTexcoord5 : TEXCOORD5,
                out float4 oPosition : SV_Position)
            {
                oPosition = Position;
                oTexcoord0.xy = PosToCoord(Position.xy);
                oTexcoord1 = oTexcoord0.xyxy + float4(float2(0, bloomOffset[0]), float2(0, bloomOffset[1])) * texSourceSizeInv.y;
                oTexcoord2 = oTexcoord0.xyxy + float4(float2(0, bloomOffset[2]), float2(0, bloomOffset[3])) * texSourceSizeInv.y;
                oTexcoord3 = oTexcoord0.xyxy + float4(float2(0, bloomOffset[4]), float2(0, bloomOffset[5])) * texSourceSizeInv.y;
                oTexcoord4 = oTexcoord0.xyxy + float4(float2(0, bloomOffset[6]), float2(0, bloomOffset[7])) * texSourceSizeInv.y;
                oTexcoord5 = oTexcoord0.xyxy + float4(float2(0, bloomOffset[8]), float2(0, bloomOffset[9])) * texSourceSizeInv.y;
            }

            float4 BlurPS(
                in float4 coord0 : TEXCOORD0,
                in float4 coord1 : TEXCOORD1,
                in float4 coord2 : TEXCOORD2,
                in float4 coord3 : TEXCOORD3,
                in float4 coord4 : TEXCOORD4,
                in float4 coord5 : TEXCOORD5) : SV_Target0
            {
                float4 color = 0;
                color += texSource.SampleLevel(PointClamp, coord0.xy, texSourceLevel) * bloomWeight[0];
                color += texSource.SampleLevel(PointClamp, coord1.xy, texSourceLevel) * bloomWeight[1];
                color += texSource.SampleLevel(PointClamp, coord1.zw, texSourceLevel) * bloomWeight[2];
                color += texSource.SampleLevel(PointClamp, coord2.xy, texSourceLevel) * bloomWeight[3];
                color += texSource.SampleLevel(PointClamp, coord2.zw, texSourceLevel) * bloomWeight[4];
                color += texSource.SampleLevel(PointClamp, coord3.xy, texSourceLevel) * bloomWeight[5];
                color += texSource.SampleLevel(PointClamp, coord3.zw, texSourceLevel) * bloomWeight[6];
                color += texSource.SampleLevel(PointClamp, coord4.xy, texSourceLevel) * bloomWeight[7];
                color += texSource.SampleLevel(PointClamp, coord4.zw, texSourceLevel) * bloomWeight[8];
                color += texSource.SampleLevel(PointClamp, coord5.xy, texSourceLevel) * bloomWeight[9];
                color += texSource.SampleLevel(PointClamp, coord5.zw, texSourceLevel) * bloomWeight[10];

                return color;
            }

            float4 FimicTongMappingPS(in float4 coord : TEXCOORD0) : SV_Target0
            {
                float aveLum = texLumAve.Sample(PointClamp, float2(0,0)).r;
                float3 color = texSource.Sample(PointClamp, coord.xy).rgb;
                color += texBloom.SampleLevel(PointClamp, coord.xy, 0).rgb;
                color += texBloom.SampleLevel(PointClamp, coord.xy, 1).rgb;
                color += texBloom.SampleLevel(PointClamp, coord.xy, 2).rgb;
                color += texBloom.SampleLevel(PointClamp, coord.xy, 3).rgb;
                float3 LDR = ToneMapping(color, aveLum, exposure);
                return float4(LDR, luminance(LDR));
            }
        ]]>
    </shader>
    <technique name="SumLum">
        <pass name="p0">
            <state name="inputlayout" value="POS3F"/>
            <state name="vertex" value="SumLumVS" />
            <state name="fragment" value="SumLumPS" />

            <state name="depthtest" value="false"/>
            <state name="depthwrite" value="false"/>

            <state name="cullmode" value="none"/>
        </pass>
    </technique>
    <technique name="SumLumLog">
        <pass name="p0">
            <state name="inputlayout" value="POS3F"/>
            <state name="vertex" value="SumLumVS" />
            <state name="fragment" value="SumLumLogPS" />

            <state name="depthtest" value="false"/>
            <state name="depthwrite" value="false"/>

            <state name="cullmode" value="none"/>
        </pass>
    </technique>
    <technique name="AvgLuminance">
        <pass name="p0">
            <state name="inputlayout" value="POS3F"/>
            <state name="vertex" value="SumLumVS" />
            <state name="fragment" value="AvgLuminancePS" />

            <state name="depthtest" value="false"/>
            <state name="depthwrite" value="false"/>

            <state name="cullmode" value="none"/>
        </pass>
    </technique>
    <technique name="GenerateBloom">
        <pass name="p0">
            <state name="inputlayout" value="POS3F"/>
            <state name="vertex" value="PostProcessVS" />
            <state name="fragment" value="BloomPS" />

            <state name="depthtest" value="false"/>
            <state name="depthwrite" value="false"/>

            <state name="cullmode" value="none"/>
        </pass>
    </technique>
    <technique name="BlurBloomh">
        <pass name="p0">
            <state name="inputlayout" value="POS3F"/>
            <state name="vertex" value="BlurXVS" />
            <state name="fragment" value="BlurPS" />

            <state name="depthtest" value="false"/>
            <state name="depthwrite" value="false"/>

            <state name="cullmode" value="none"/>
        </pass>
    </technique>
    <technique name="BlurBloomv">
        <pass name="p0">
            <state name="inputlayout" value="POS3F"/>
            <state name="vertex" value="BlurYVS" />
            <state name="fragment" value="BlurPS" />

            <state name="depthtest" value="false"/>
            <state name="depthwrite" value="false"/>

            <state name="cullmode" value="none"/>
        </pass>
    </technique>
    <technique name="FimicTongMapping">
        <pass name="p0">
            <state name="inputlayout" value="POS3F"/>
            <state name="vertex" value="PostProcessVS" />
            <state name="fragment" value="FimicTongMappingPS" />

            <state name="depthtest" value="false"/>
            <state name="depthwrite" value="false"/>

            <state name="cullmode" value="none"/>
        </pass>
    </technique>
</effect>