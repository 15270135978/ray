<?xml version="1.0"?>
<effect version="1270" language="hlsl">
    <shader>
    	<![CDATA[
		#define InvLog2 3.32192809489f
		#define InvPIE 0.318309886142f
		#define InvPIE8 0.039788735767f
		#define InvPIE4 0.079577471535f
		#define PIE 3.141592654f

		float3 srgb2linear(float3 rgb)
		{
			// apply gamma correction using exact sRGB curve
			const float ALPHA = 0.055f;
			return rgb < 0.04045f ? rgb / 12.92f : pow((max(rgb,1e-5) + ALPHA) / (1 + ALPHA), 2.4f);
		}

		float3 linear2srgb(float3 srgb)
		{
			// apply gamma correction using exact sRGB curve
			const float ALPHA = 0.055f;
			return srgb < 0.0031308f ? 12.92f * srgb : (1 + ALPHA) * pow(max(srgb,1e-5), 1 / 2.4f) - ALPHA;
		}

		float4 srgb2linear(float4 c)
		{
			return float4(srgb2linear(c.rgb), c.a);
		}

		float4 linear2srgb(float4 c)
		{
			return float4(linear2srgb(c.rgb), c.a);
		}

		float3 rgb2ycbcr(float3 rgb)
		{
			// rgb2ycbcr
			float Y = 0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b;
			float Cb = 0.5 + (-0.168 * rgb.r - 0.331 * rgb.g + 0.5 * rgb.b);
			float Cr = 0.5 + (0.5 * rgb.r - 0.418 * rgb.g - 0.081 * rgb.b);
			return float3(Y, Cb, Cr);
		}

		float3 ycbcr2rgb(float3 YCbCr)
		{
			// ycbcr2rgb
			float R = YCbCr.r + 1.402 * (YCbCr.b - 0.5);
			float G = YCbCr.r - 0.344 * (YCbCr.g - 0.5) - 0.714 * (YCbCr.b - 0.5);
			float B = YCbCr.r + 1.772 * (YCbCr.g - 0.5);
			return float3(R, G, B);
		}

		float3 ycbcrMulycbcr(float3 YCbCr1, float3 YCbCr2)
		{
			float Y = YCbCr1.r * YCbCr2.r;
			float Cb = (YCbCr1.g + YCbCr2.g) * 0.5;
			float Cr = (YCbCr1.b + YCbCr2.b) * 0.5;
			return float3(Y, Cb, Cr);
		}

		float3 ycbcrAddycbcr(float3 YCbCr1, float3 YCbCr2)
		{
			float Y = (YCbCr1.r + YCbCr2.r);
			float Cb = (YCbCr1.g + YCbCr2.g) * 0.5;
			float Cr = (YCbCr1.b + YCbCr2.b) * 0.5;
			return float3(Y, Cb, Cr);
		}

		float3 rgb2xyz(float3 rgb)
		{
			const float3x3 m = float3x3 (
				0.5141364, 0.3238786, 0.16036376,
				0.265068, 0.67023428, 0.06409157,
				0.0241188, 0.1228178, 0.84442666);
			return mul(m, rgb);
		}

		float3 xyz2rgb(float3 xyz)
		{
			const float3x3 m = float3x3(
				2.5651, -1.1665, -0.3986,
				-1.0217, 1.9777, 0.0439,
				0.0753, -0.2543, 1.1892);
			return mul(m, xyz);
		}

		float3 xyz2yxy(float3 xyz)
		{
			float w = xyz.r + xyz.g + xyz.b;
			if (w > 0.0)
			{
				float3 Yxy;
				Yxy.r = xyz.g;
				Yxy.g = xyz.r / w;
				Yxy.b = xyz.g / w;
				return Yxy;
			}
			else
			{
				return float3(0.0, 0.0, 0.0);
			}
		}

		float3 yxy2xyz(float3 Yxy)
		{
			float3 xyz;
			xyz.g = Yxy.r;
			if (Yxy.b > 0.0f)
			{
				xyz.r = Yxy.r * Yxy.g / Yxy.b;
				xyz.b = Yxy.r * (1.0f - Yxy.g - Yxy.b) / Yxy.b;
			}
			else
			{
				xyz.rb = float2(0.0, 0.0);
			}
			return xyz;
		}

        float3 rgb2hsv(float3 rgb) 
        {
            float minValue = min(min(rgb.r, rgb.g), rgb.b);
            float maxValue = max(max(rgb.r, rgb.g), rgb.b);
            float d = maxValue - minValue;

            float3 hsv = 0.0;
            hsv.b = maxValue;
            if (d != 0) 
            {
                hsv.g = d / maxValue;

                float3 delrgb = (((maxValue.xxx - rgb) / 6.0) + d / 2.0) / d;
                if      (maxValue == rgb.r) { hsv.r = delrgb.b - delrgb.g; }
                else if (maxValue == rgb.g) { hsv.r = 1.0 / 3.0 + delrgb.r - delrgb.b; }
                else if (maxValue == rgb.b) { hsv.r = 2.0 / 3.0 + delrgb.g - delrgb.r; }

                if (hsv.r < 0.0) { hsv.r += 1.0; }
                if (hsv.r > 1.0) { hsv.r -= 1.0; }
            }
            return hsv;
        }


        float3 hsv2rgb(float3 hsv)
        {
            float h = hsv.r;
            float s = hsv.g;
            float v = hsv.b;

            float3 rgb = v;
            if (hsv.g != 0.0)
            {
                float h_i = floor(6 * h);
                float f = 6 * h - h_i;

                float p = v * (1.0f - s);
                float q = v * (1.0f - f * s);
                float t = v * (1.0f - (1.0f - f) * s);

                if (h_i == 0) { rgb = float3(v, t, p); }
                else if (h_i == 1) { rgb = float3(q, v, p); }
                else if (h_i == 2) { rgb = float3(p, v, t); }
                else if (h_i == 3) { rgb = float3(p, q, v); }
                else if (h_i == 4) { rgb = float3(t, p, v); }
                else { rgb = float3(v, p, q); }
            }
            return rgb;
        }

		float luminance(float3 rgb)
		{
			const float3 lumfact = float3(0.2126f, 0.7152f, 0.0722f);
			return dot(rgb, lumfact);
		}

		// https://dl.dropboxusercontent.com/u/16861957/gdc2015_rendering_the_world_of_far_cry_4.pdf
		float4 TangentSpaceToQuaternion(float3 tangent, float3 binormal, float3 normal)
		{
			float4 quat;
			quat.x = normal.y - binormal.z;
			quat.y = tangent.z - normal.x;
			quat.z = binormal.x - tangent.y;
			quat.w = 1.0f + tangent.x + binormal.y + normal.z;
			return normalize(quat);
		}

		float3 QuaternionToTangentSpace(float4 quat)
		{
			return
				float3( 1.0f,  0.0f,  0.0f) +
				float3(-2.0f,  2.0f,  2.0f) * quat.y * quat.yxw +
				float3(-2.0f, -2.0f,  2.0f) * quat.z * quat.zwx;
		}

		float3 QuaternionToTangentSpaceBinormal(float4 quat)
		{
			return
				float3( 0.0f,  1.0f,  0.0f) +
				float3( 2.0f, -2.0f,  2.0f) * quat.z * quat.wzy +
				float3( 2.0f, -2.0f, -2.0f) * quat.x * quat.yxw;
		}

		float3 QuaternionToTangentSpaceNormal(float4 quat)
		{
			return
				float3( 0.0f,  0.0f,  1.0f) +
				float3( 2.0f,  2.0f, -2.0f) * quat.x * quat.zwx +
				float3(-2.0f,  2.0f, -2.0f) * quat.y * quat.wzy;
		}

		// http://www.crytek.com/download/izfrey_siggraph2011.pdf
		float3 QuaternionTransform(float3 v, float4 quat)
		{
			return v + cross(quat.xyz, cross(quat.xyz, v) + quat.w * v) * 2;
		}

		float3 QuaternionToTangent(float4 quat)
		{
			return QuaternionTransform(float3(1, 0, 0), quat);
		}

		float3 QuaternionToBinormal(float4 quat)
		{
			return QuaternionTransform(float3(0, 1, 0), quat);
		}

		float3 QuaternionToNormal(float4 quat)
		{
			return QuaternionTransform(float3(0, 0, 1), quat);
		}

		float4 SmoothCurve(float4 x)
		{
			return x * x * (3.0 - 2.0 * x);
		}

		float4 TriangleWave(float4 x)
		{
			return abs(frac(x + 0.5) * 2.0 - 1.0);
		}

		float4 SmoothTriangleWave(float4 x)
		{
			return SmoothCurve(TriangleWave(x));
		}

		float3 PremultipliedAlpha(float4 color)
		{
			return color.rgb * color.a;
		}

		float3 PremultipliedBlend(float3 src, float3 dst, float alpha)
		{
			return src * alpha + dst;
		}

		float fastAcos(float x)
		{
			return sqrt(1.0 - x) * (1.5707963267948966192313216916398f + x * (-0.213300989f + x * (0.077980478f + x * -0.02164095f)));
		}

        float2 PosToCoord(float2 Position)
        {
            return mad(Position, 0.5, 0.5);
        }

        float3 PosToCoord(float3 Position)
        {
            return mad(Position, 0.5, 0.5);
        }

        float4 PosToCoord(float4 Position)
        {
            return mad(Position, 0.5, 0.5);
        }

        float2 CoordToPos(float2 coord)
        {
            return mad(coord, 2.0, -1.0);
        }

        float3 CoordToPos(float3 coord)
        {
            return mad(coord, 2.0, -1.0);
        }

        float4 CoordToPos(float4 coord)
        {
            return mad(coord, 2.0, -1.0);
        }

        float linearDepthOrthoLH(float2 clipConstant, float depth)
        {
            // clipConstant.x = znear;
            // clipConstant.y = zfar - znear;
            return clipConstant.x + clipConstant.y * depth;
        }

        float linearDepthPerspectiveFovLH(float2 clipConstant, float depth)
        {
            // clipConstant.x = _znear * (_zfar / (_zfar - _znear));
            // clipConstant.y = _zfar / (_zfar - _znear);
            return clipConstant.x / (clipConstant.y - depth);
        }

        float linearDepthPerspectiveOffCenterLH(float3 clipConstant, float depth)
        {
            // clipConstant.x = (2 * znear * zfar);
            // clipConstant.y = zfar + znear;
            // clipConstant.z = zfar - znear;
            return clipConstant.x / (clipConstant.y - clipConstant.z * depth);
        }

        float3 computeTangent(float3 viewdir, float2 coord)
        {
            float3 dp1 = ddx(viewdir);
            float3 dp2 = ddy(viewdir);
            float2 duv1 = ddx(coord);
            float2 duv2 = ddy(coord);

            float3x3 M = float3x3(dp1, dp2, cross(dp1, dp2));
            float2x3 I = float2x3(cross(M[1], M[2]), cross(M[2], M[0]));
            float3 T = mul(float2(duv1.x, duv2.x), I);
            return normalize(T);
        }

        float3 computeBinormal(float3 N, float3 viewdir, float2 coord)
        {
            float3 dp1 = ddx(viewdir);
            float3 dp2 = ddy(viewdir);
            float2 duv1 = ddx(coord);
            float2 duv2 = ddy(coord);

            float3x3 M = float3x3(dp1, dp2, cross(dp1, dp2));
            float2x3 I = float2x3(cross(M[1], M[2]), cross(M[2], M[0]));
            float3 B = mul(float2(duv1.y, duv2.y), I);
            return normalize(B);
        }

        float3x3 computeTangentBinormalNormal(float3 N, float3 viewdir, float2 coord)
        {
            float3 dp1 = ddx(viewdir);
            float3 dp2 = ddy(viewdir);
            float2 duv1 = ddx(coord);
            float2 duv2 = ddy(coord);

            float3x3 M = float3x3(dp1, dp2, cross(dp1, dp2));
            float2x3 I = float2x3(cross(M[1], M[2]), cross(M[2], M[0]));
            float3 T = mul(float2(duv1.x, duv2.x), I);
            float3 B = mul(float2(duv1.y, duv2.y), I);

            return float3x3(normalize(T), normalize(B), N);
        }

        float2 computeSphereCoord(float3 normal)
        {
            const float invPI = 1.0f / 3.1415926;
            float2 coord = float2(atan2(normal.x, normal.z) * invPI * 0.5f + 0.5f, fastAcos(normal.y) * invPI);
            return coord;
        }
    	]]>
    </shader>
 </effect>