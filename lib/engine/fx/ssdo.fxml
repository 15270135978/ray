<?xml version="1.0"?>
<effect language="hlsl">
	<include name="sys:fx/sampler.fxml"/>
	<include name="sys:fx/gbuffer.fxml"/>
	<include name="sys:fx/inputlayout.fxml"/>
	<macro name="NUM_SAMPLES" type="int" value="12"/>
	<macro name="NUM_SAMPLES_INV" type="float" value="0.1"/>
	<macro name="BLUR_RADIUS" type="int" value="8"/>
	<parameter name="projScale" type="float"/>
	<parameter name="radius" type="float"/>
	<parameter name="sphere[NUM_SAMPLES]" type="float2[]"/>
	<parameter name="bias" type="float"/>
	<parameter name="intensity" type="float"/>
	<parameter name="blurFactor" type="float" />
	<parameter name="blurSharpness" type="float" />
	<parameter name="blurDirection" type="float2"/>
	<parameter name="texDepth" type="texture2D" semantic="DepthLinearMap" />
	<parameter name="texNormal" type="texture2D" semantic="NormalMap" />
	<parameter name="texSource" type="texture2D"/>
	<parameter name="texSourceInv" type="float2"/>
	<parameter name="matProjectInverse" type="float4x4" semantic="matProjectInverse" />
	<shader>
		<![CDATA[
			float linearizeDepth(float2 uv)
			{
				return texDepth.SampleLevel(PointClamp, uv, 0).r;
			}

			float3 GetViewNormal(float2 uv)
			{
				float4 MRT1 = texNormal.SampleLevel(PointClamp, uv, 0);
				return DecodeGBufferNormal(MRT1);
			}

			float3 GetViewPosition(float2 uv, float3 viewdir)
			{
				return restorePosition(texDepth, uv, viewdir);
			}

			float3 GetViewPosition(float2 uv)
			{
				float3 viewdir = mul(matProjectInverse, float4(CoordToPos(uv), 0, 1)).xyz;
				float depth = texDepth.Sample(PointClamp, uv).r;
				return viewdir * depth / viewdir.z;
			}

			float2 tapLocation(int sampleIndex, float2 sampleNoise, float radius)
			{
				float cosacosb = sphere[sampleIndex].x * sampleNoise.x;
				float sinacosb = sphere[sampleIndex].y * sampleNoise.x;
				float cosasinb = sphere[sampleIndex].x * sampleNoise.y;
				float sinasinb = sphere[sampleIndex].y * sampleNoise.y;
				return float2(cosacosb-sinasinb, sinacosb+cosasinb) * radius * (float(sampleIndex) * NUM_SAMPLES_INV);
			}

			void ScreenSpaceDirOccPassVS(
				in float4 Position : POSITION0,
				out float4 oTexcoord : TEXCOORD0,
				out float3 oViewDir : TEXCOORD1,
				out float4 oPosition : SV_Position)
			{
				oPosition = Position;
				oViewDir  = mul(matProjectInverse, Position).xyz;
				oTexcoord = PosToCoord(Position.xy).xyxy;
			}

			float ScreenSpaceDirOccPassPS(
				in float4 coord : TEXCOORD0,
				in float3 viewdir : TEXCOORD1,
				in float4 screenSpace : SV_Position) : SV_Target
			{
				float3 viewNormal = GetViewNormal(coord.xy);
				float3 viewPosition = GetViewPosition(coord.xy, normalize(viewdir));

				float sampleJitter = GetJitterOffset(screenSpace.xy) * PI_2;
				float sampleAmbient = 0.0f;
				float sampleWeight = 0.0f;

				float2 sampleNoise;
				sincos(sampleJitter, sampleNoise.x, sampleNoise.y);

				for (int i = 0; i < NUM_SAMPLES; i += 4)
				{
					float2 sampleOffset[4];
					sampleOffset[0] = coord.xy + tapLocation(i + 0, sampleNoise, radius) * texSourceInv;
					sampleOffset[1] = coord.xy + tapLocation(i + 1, sampleNoise, radius) * texSourceInv;
					sampleOffset[2] = coord.xy + tapLocation(i + 2, sampleNoise, radius) * texSourceInv;
					sampleOffset[3] = coord.xy + tapLocation(i + 3, sampleNoise, radius) * texSourceInv;

					float3 samplePosition[4];
					samplePosition[0] = GetViewPosition(sampleOffset[0]);
					samplePosition[1] = GetViewPosition(sampleOffset[1]);
					samplePosition[2] = GetViewPosition(sampleOffset[2]);
					samplePosition[3] = GetViewPosition(sampleOffset[3]);

					float3 sampleDirection[4];
					sampleDirection[0] = samplePosition[0] - viewPosition;
					sampleDirection[1] = samplePosition[1] - viewPosition;
					sampleDirection[2] = samplePosition[2] - viewPosition;
					sampleDirection[3] = samplePosition[3] - viewPosition;

					float4 sampleLength2 = float4(
						dot(sampleDirection[0], sampleDirection[0]),
						dot(sampleDirection[1], sampleDirection[1]),
						dot(sampleDirection[2], sampleDirection[2]),
						dot(sampleDirection[3], sampleDirection[3]));

					float4 sampleLengthInv = rsqrt(sampleLength2 + 1e-5);

					float4 sampleAngle = float4(
						dot(sampleDirection[0], viewNormal),
						dot(sampleDirection[1], viewNormal),
						dot(sampleDirection[2], viewNormal),
						dot(sampleDirection[3], viewNormal));

					sampleWeight += 4.0f;
					sampleAmbient += sum(max(0.0f, (sampleAngle - viewPosition.z * bias)) * sampleLengthInv);
				}

				return max(0.0f, 1 - sampleAmbient / sampleWeight * intensity);
			}

			void PostProcessVS(
				in float4 Position : POSITION0,
				out float4 oTexcoord : TEXCOORD0,
				out float3 oViewDir : TEXCOORD1,
				out float4 oPosition : SV_Position)
			{
				oPosition = Position;
				oViewDir  = mul(matProjectInverse, Position).xyz;
				oTexcoord = PosToCoord(Position.xy).xyxy;
			}

			float4 BilateralFilterPS(in float2 coord : TEXCOORD0) : SV_Target
			{
				float center_d = linearizeDepth(coord);

				float4 total_c = texSource.SampleLevel(PointClamp, coord, 0);
				float total_w = 1.0f;

				float2 offset1 = coord + blurDirection;
				float2 offset2 = coord - blurDirection;

				for (int r = 1; r < BLUR_RADIUS; r++)
				{
					float2 depth = float2(linearizeDepth(offset1), linearizeDepth(offset2));
					float2 weight = exp2(-r * r * blurFactor - pow2((depth - center_d) * blurSharpness));

					total_c += texSource.SampleLevel(PointClamp, offset1, 0) * weight.r;
					total_c += texSource.SampleLevel(PointClamp, offset2, 0) * weight.g;

					total_w += weight.r;
					total_w += weight.g;

					offset1 += blurDirection;
					offset2 -= blurDirection;
				}

				return total_c / total_w;
			}

			float4 ApplyPS(in float2 coord : TEXCOORD) : SV_Target
			{
				float ao = texSource.SampleLevel(PointClamp, coord, 0).r;
				return ao * ao;
			}
		]]>
	</shader>
	<technique name="ComputeAO">
		<pass name="p0">
			<state name="inputlayout" value="POS3F"/>
			<state name="vertex" value="ScreenSpaceDirOccPassVS"/>
			<state name="fragment" value="ScreenSpaceDirOccPassPS"/>

			<state name="cullmode" value="none"/>

			<state name="depthtest" value="false"/>
			<state name="depthwrite" value="false"/>
		</pass>
	</technique>
	<technique name="BlurXAO">
		<pass name="p0">
			<state name="inputlayout" value="POS3F"/>
			<state name="vertex" value="PostProcessVS"/>
			<state name="fragment" value="BilateralFilterPS"/>

			<state name="cullmode" value="none"/>

			<state name="depthtest" value="false"/>
			<state name="depthwrite" value="false"/>
		</pass>
	</technique>
	<technique name="BlurYAO">
		<pass name="p0">
			<state name="inputlayout" value="POS3F"/>
			<state name="vertex" value="PostProcessVS"/>
			<state name="fragment" value="BilateralFilterPS"/>

			<state name="cullmode" value="none"/>

			<state name="depthtest" value="false"/>
			<state name="depthwrite" value="false"/>
		</pass>
	</technique>
	<technique name="Apply">
		<pass name="p0">
			<state name="inputlayout" value="POS3F"/>
			<state name="vertex" value="PostProcessVS"/>
			<state name="fragment" value="ApplyPS"/>

			<state name="cullmode" value="none"/>

			<state name="depthtest" value="false"/>
			<state name="depthwrite" value="false"/>

			<state name="blend" value="true"/>
			<state name="blendsrc" value="dstcol" />
			<state name="blenddst" value="zero" />
			<state name="blendalphasrc" value="zero" />
			<state name="blendalphadst" value="one" />
		</pass>
	</technique>
</effect>