<?xml version="1.0"?>
<effect language="hlsl">
    <include name="sys:fx/GBuffer.fxml"/>
    <include name="sys:fx/lighting.fxml"/>
    <include name="sys:fx/inputlayout.fxml"/>
    <parameter name="matModelView" type="float4x4" semantic="matModelView"/>
    <parameter name="matModelViewProject" type="float4x4" semantic="matModelViewProject"/>
    <parameter name="matProjectInverse" type="float4x4" semantic="matProjectInverse" />
    <parameter name="texMRT0" type="texture2D" semantic="DeferredGraphicMap" />
    <parameter name="texMRT1" type="texture2D" semantic="DeferredNormalMap" />
    <parameter name="texDepth" type="texture2D" semantic="DeferredDepthMap" />
    <parameter name="texDepthLinear" type="texture2D" semantic="DeferredDepthLinearMap" />
    <parameter name="texLight" type="texture2D" semantic="DeferredLightMap" />
    <parameter name="texSource" type="texture2D"/>
    <parameter name="texEnvironmentMap" type="texture2D"/>
    <parameter name="clipInfo" type="float2"/>
    <parameter name="projInfo" type="float4"/>
    <parameter name="lightColor" type="float3" />
    <parameter name="lightEyeDirection" type="float3" />
    <parameter name="lightEyePosition" type="float3" />
    <parameter name="lightAttenuation" type="float3"/>
    <parameter name="lightOuterInner" type="float2"/>
    <parameter name="shadowMap" type="texture2D" />
    <parameter name="shadowFactor" type="float4"/>
    <parameter name="shadowView2LightView" type="float4"/>
    <parameter name="shadowView2LightViewProject" type="float4x4" />
    <shader>
        <![CDATA[
            void DeferredDepthOnlyVS(
                in float4 Position : POSITION,
                out float4 oPosition : SV_Position)
            {
                oPosition = mul(Position, matModelViewProject);
            }

            void DeferredScreenQuadVS(
                in float4 Position : POSITION,
                out float2 oTexcoord : TEXCOORD0,
                out float4 oPosition : SV_Position)
            {
                oPosition = Position;
                oTexcoord = PosToCoord(Position.xy);
            }

            void DeferredLightingVS(
                in float4 Position : POSITION,
                out float2 oTexcoord : TEXCOORD0,
                out float3 oViewDir : TEXCOORD1,
                out float4 oPosition : SV_Position)
            {
                oPosition = Position;
                oViewDir  = -mul(Position, matProjectInverse).xyz;
                oTexcoord = PosToCoord(Position.xy);
            }

            void DeferredLighting2VS(
                in float4 Position : POSITION,
                out float3 oTexcoord : TEXCOORD0,
                out float3 oViewDir : TEXCOORD1,
                out float4 oPosition : SV_Position)
            {
                oViewDir = mul(Position, matModelView).xyz;
                oPosition = mul(Position, matModelViewProject);
                oTexcoord.xy = PosToCoord(oPosition.xy / oPosition.w);
                oTexcoord.xy = oTexcoord.xy * oPosition.w;
                oTexcoord.z = oPosition.w;
            }

            void DeferredDepthOnlyPS()
            {
            }

            float4 DeferredDepthLinearPS(in float2 coord : TEXCOORD0) : SV_Target
            {
                float d = texDepth.Sample(PointClamp, coord).r;
                return linearDepthPerspectiveFovLH(clipInfo, d);
            }

            float4 DeferredCopyOnlyPS(in float2 coord : TEXCOORD0) : SV_Target
            {
                return texSource.Sample(PointClamp, coord);
            }

            float4 DeferredAmbientLightPS(in float2 coord : TEXCOORD0, in float3 viewdir : TEXCOORD1) : SV_Target
            {
                float4 MRT1 = texMRT1.Sample(PointClamp, coord);

                float3 N = restoreNormal(MRT1);
                float3 L = -lightEyeDirection;

                float4 lighting;
                lighting.rgb = saturate(dot(N, L) * 0.5 + 0.5) * lightColor;
                lighting.a = 0;
                return lighting;
            }

            float4 DeferredSunLightPS(in float2 coord : TEXCOORD0, in float3 viewdir : TEXCOORD1) : SV_Target
            {
                float4 MRT1 = texMRT1.Sample(PointClamp, coord);
                float4 MRT0 = texMRT0.Sample(PointClamp, coord);

                float shininess = restoreShininess(MRT1);
                float specular = restoreSpecular(MRT0);

                float3 N = restoreNormal(MRT1);
                float3 P = restorePosition(texDepthLinear, projInfo, coord);
                float3 V = normalize(viewdir);
                float3 L = -lightEyeDirection;
                float4 lighting = 0;

                float NL = dot(N, L);
                if (NL > 0)
                {
                    lighting.rgb = brdfLambert(N, L, lightColor);
                    lighting.a = brdfSpecular(N, L, V, shininess, specular);
                }

                return lighting;
            }

            float4 DeferredSunLightShadowPS(in float2 coord : TEXCOORD0, in float3 viewdir : TEXCOORD1) : SV_Target
            {
                float4 MRT1 = texMRT1.Sample(PointClamp, coord);
                float4 MRT0 = texMRT0.Sample(PointClamp, coord);

                float shininess = restoreShininess(MRT1);
                float specular = restoreSpecular(MRT0);

                float3 N = restoreNormal(MRT1);
                float3 P = restorePosition(texDepthLinear, projInfo, coord);
                float3 V = normalize(viewdir);
                float3 L = -lightEyeDirection;
                float4 lighting = 0;

                float NL = dot(N, L);
                if (NL > 0)
                {
                    lighting.rgb = brdfLambert(N, L, lightColor);
                    lighting.a = brdfSpecular(N, L, V, shininess, specular);
                    lighting *= shadowLighting(shadowMap, shadowView2LightViewProject, shadowView2LightView, shadowFactor, P);
                }

                return lighting;
            }

            float4 DeferredDirectionalLightPS(in float2 coord : TEXCOORD0, in float3 viewdir : TEXCOORD1) : SV_Target
            {
                float4 MRT1 = texMRT1.Sample(PointClamp, coord);
                float4 MRT0 = texMRT0.Sample(PointClamp, coord);

                float shininess = restoreShininess(MRT1);
                float specular = restoreSpecular(MRT0);

                float3 N = restoreNormal(MRT1);
                float3 P = restorePosition(texDepthLinear, projInfo, coord);
                float3 V = normalize(viewdir);
                float3 L = -lightEyeDirection;
                float4 lighting = 0;

                float NL = dot(N, L);
                if (NL > 0)
                {
                    lighting.rgb = brdfLambert(N, L, lightColor);
                    lighting.a = brdfSpecular(N, L, V, shininess, specular);
                }

                return lighting;
            }

            float4 DeferredDirectionalLightShadowPS(in float2 coord : TEXCOORD0, in float3 viewdir : TEXCOORD1) : SV_Target
            {
                float4 MRT1 = texMRT1.Sample(PointClamp, coord);
                float4 MRT0 = texMRT0.Sample(PointClamp, coord);

                float shininess = restoreShininess(MRT1);
                float specular = restoreSpecular(MRT0);

                float3 N = restoreNormal(MRT1);
                float3 P = restorePosition(texDepthLinear, projInfo, coord);
                float3 V = normalize(viewdir);
                float3 L = -lightEyeDirection;
                float4 lighting = 0;

                float NL = dot(N, L);
                if (NL > 0)
                {
                    lighting.rgb = brdfLambert(N, L, lightColor);
                    lighting.a = brdfSpecular(N, L, V, shininess, specular);
                    lighting *= shadowLighting(shadowMap, shadowView2LightViewProject, shadowView2LightView, shadowFactor, P);
                }

                return lighting;
            }

            float4 DeferredSpotLightPS(in float3 coord : TEXCOORD0, in float3 viewdir : TEXCOORD1) : SV_Target
            {
                float2 texcoord = coord.xy / coord.z;

                float4 MRT1 = texMRT1.Sample(PointClamp, texcoord);
                float4 MRT0 = texMRT0.Sample(PointClamp, texcoord);

                float shininess = restoreShininess(MRT1);
                float specular = restoreSpecular(MRT0);

                float3 N = restoreNormal(MRT1);
                float3 P = restorePosition(texDepthLinear, projInfo, texcoord);
                float3 V = normalize(-viewdir);
                float3 L = normalize(lightEyePosition - P);
                float4 lighting = 0;

                float spot = spotLighting(lightEyePosition, lightEyeDirection, lightOuterInner, P);
                if (spot > 0)
                {
                    lighting.rgb = brdfLambert(N, L, lightColor);
                    lighting.a = brdfSpecular(N, L, V, shininess, specular);
                    lighting *= attenuationTerm(lightEyePosition, P, lightAttenuation);
                    lighting *= spot;
                }

                return lighting;
            }

            float4 DeferredSpotLightShadowPS(in float3 coord : TEXCOORD0, in float3 viewdir : TEXCOORD1) : SV_Target
            {
                float2 texcoord = coord.xy / coord.z;

                float4 MRT1 = texMRT1.Sample(PointClamp, texcoord);
                float4 MRT0 = texMRT0.Sample(PointClamp, texcoord);

                float shininess = restoreShininess(MRT1);
                float specular = restoreSpecular(MRT0);

                float3 N = restoreNormal(MRT1);
                float3 P = restorePosition(texDepthLinear, projInfo, texcoord);
                float3 V = normalize(-viewdir);
                float3 L = normalize(lightEyePosition - P);
                float4 lighting = 0;

                float spot = spotLighting(lightEyePosition, lightEyeDirection, lightOuterInner, P);
                if (spot > 0)
                {
                    lighting.rgb = brdfLambert(N, L, lightColor);
                    lighting.a = brdfSpecular(N, L, V, shininess, specular);
                    lighting *= attenuationTerm(lightEyePosition, P, lightAttenuation);
                    lighting *= shadowLighting(shadowMap, shadowView2LightViewProject, shadowView2LightView, shadowFactor, P);
                    lighting *= spot;
                }

                return lighting;
            }

            float4 DeferredPointLightPS(in float3 coord : TEXCOORD0, in float3 viewdir : TEXCOORD1) : SV_Target
            {
                float2 texcoord = coord.xy / coord.z;

                float4 MRT1 = texMRT1.Sample(PointClamp, texcoord);
                float4 MRT0 = texMRT0.Sample(PointClamp, texcoord);

                float shininess = restoreShininess(MRT1);
                float specular = restoreSpecular(MRT0);

                float3 N = restoreNormal(MRT1);
                float3 P = restorePosition(texDepthLinear, projInfo, texcoord);
                float3 V = normalize(-viewdir);
                float3 L = normalize(lightEyePosition - P);
                float4 lighting = 0;

                float NL = dot(N, L);
                if (NL > 0)
                {
                    lighting.rgb = brdfLambert(N, L, lightColor);
                    lighting.a = brdfSpecular(N, L, V, shininess, specular);
                    lighting *= attenuationTerm(lightEyePosition, P, lightAttenuation);
                }

                return lighting;
            }

            float4 DeferredShadingOpaquesPS(in float2 coord : TEXCOORD0) : SV_Target
            {
                float4 MRT0 = texMRT0.Sample(PointClamp, coord);

                float3 diffuse = restoreDiffuse(texMRT0, coord);
                float4 light = texLight.Sample(PointClamp, coord);

                diffuse = diffuse * light.rgb + light.rgb * light.a;

                return float4(diffuse, 1.0);
            }

            float4 DeferredShadingTransparentsPS(in float2 coord : TEXCOORD0) : SV_Target
            {
                float4 MRT0 = texMRT0.Sample(PointClamp, coord);

                float3 diffuse = restoreDiffuse(texMRT0, coord);
                float4 light = texLight.Sample(PointClamp, coord);

                diffuse = diffuse * light.rgb + light.rgb * light.a;

                return float4(diffuse, 1.0);
            }
        ]]>
    </shader>
    <technique name="DeferredDepthOnly">
        <pass name="p0">
            <state name="inputlayout" value="POS3F"/>
            <state name="vertex" value="DeferredDepthOnlyVS"/>
            <state name="fragment" value="DeferredDepthOnlyPS"/>
        </pass>
    </technique>
    <technique name="DeferredDepthLinear">
        <pass name="p0">
            <state name="inputlayout" value="POS3F"/>

            <state name="vertex" value="DeferredScreenQuadVS"/>
            <state name="fragment" value="DeferredDepthLinearPS"/>

            <state name="cullmode" value="none"/>

            <state name="depthtest" value="false"/>
            <state name="depthwrite" value="false"/>
        </pass>
    </technique>
    <technique name="DeferredCopyOnly">
        <pass name="p0">
            <state name="inputlayout" value="POS3F"/>

            <state name="vertex" value="DeferredScreenQuadVS"/>
            <state name="fragment" value="DeferredCopyOnlyPS"/>

            <state name="cullmode" value="none"/>

            <state name="depthtest" value="false"/>
            <state name="depthwrite" value="false"/>
        </pass>
    </technique>
    <technique name="DeferredAmbientLight">
        <pass name="p0">
            <state name="inputlayout" value="POS3F"/>

            <state name="vertex" value="DeferredLightingVS"/>
            <state name="fragment" value="DeferredAmbientLightPS"/>

            <state name="depthtest" value="false"/>
            <state name="depthwrite" value="false"/>

            <state name="cullmode" value="none"/>

            <state name="blend" value="true"/>
            <state name="blendsrc" value="one"/>
            <state name="blenddst" value="one"/>

            <state name="stencilTest" value="true"/>
            <state name="stencilFunc" value="equal"/>
            <state name="stencilTwoFunc" value="equal"/>
        </pass>
    </technique>
    <technique name="DeferredSunLight">
        <pass name="p0">
            <state name="inputlayout" value="POS3F"/>

            <state name="vertex" value="DeferredLightingVS"/>
            <state name="fragment" value="DeferredSunLightPS"/>

            <state name="depthtest" value="false"/>
            <state name="depthwrite" value="false"/>

            <state name="cullmode" value="none"/>

            <state name="blend" value="true"/>
            <state name="blendsrc" value="one"/>
            <state name="blenddst" value="one"/>

            <state name="stencilTest" value="true"/>
            <state name="stencilFunc" value="equal"/>
            <state name="stencilTwoFunc" value="equal"/>
        </pass>
    </technique>
    <technique name="DeferredSunLightShadow">
        <pass name="p0">
            <state name="inputlayout" value="POS3F"/>

            <state name="vertex" value="DeferredLightingVS"/>
            <state name="fragment" value="DeferredSunLightShadowPS"/>

            <state name="depthtest" value="false"/>
            <state name="depthwrite" value="false"/>

            <state name="cullmode" value="none"/>

            <state name="blend" value="true"/>
            <state name="blendsrc" value="one"/>
            <state name="blenddst" value="one"/>

            <state name="stencilTest" value="true"/>
            <state name="stencilFunc" value="equal"/>
            <state name="stencilTwoFunc" value="equal"/>
        </pass>
    </technique>
    <technique name="DeferredDirectionalLight">
        <pass name="p0">
            <state name="inputlayout" value="POS3F"/>

            <state name="vertex" value="DeferredLightingVS"/>
            <state name="fragment" value="DeferredDirectionalLightPS"/>

            <state name="depthtest" value="false"/>
            <state name="depthwrite" value="false"/>

            <state name="cullmode" value="none"/>

            <state name="blend" value="true"/>
            <state name="blendsrc" value="one"/>
            <state name="blenddst" value="one"/>

            <state name="stencilTest" value="true"/>
            <state name="stencilFunc" value="equal"/>
            <state name="stencilTwoFunc" value="equal"/>
        </pass>
    </technique>
    <technique name="DeferredDirectionalLightShadow">
        <pass name="p0">
            <state name="inputlayout" value="POS3F"/>

            <state name="vertex" value="DeferredLightingVS"/>
            <state name="fragment" value="DeferredDirectionalLightShadowPS"/>

            <state name="depthtest" value="false"/>
            <state name="depthwrite" value="false"/>

            <state name="cullmode" value="none"/>

            <state name="blend" value="true"/>
            <state name="blendsrc" value="one"/>
            <state name="blenddst" value="one"/>

            <state name="stencilTest" value="true"/>
            <state name="stencilFunc" value="equal"/>
            <state name="stencilTwoFunc" value="equal"/>
        </pass>
    </technique>
    <technique name="DeferredPointLight">
        <pass name="p0">
            <state name="inputlayout" value="POS3F"/>

            <state name="vertex" value="DeferredLighting2VS"/>
            <state name="fragment" value="DeferredPointLightPS"/>

            <state name="depthtest" value="false"/>
            <state name="depthwrite" value="false"/>

            <state name="blend" value="true"/>
            <state name="blendsrc" value="one"/>
            <state name="blenddst" value="one"/>

            <state name="cullmode" value="front"/>

            <state name="stencilTest" value="true"/>
            <state name="stencilFunc" value="equal"/>
            <state name="stencilTwoFunc" value="equal"/>
        </pass>
    </technique>
    <technique name="DeferredSpotLight">
        <pass name="p0">
            <state name="inputlayout" value="POS3F"/>

            <state name="vertex" value="DeferredLighting2VS"/>
            <state name="fragment" value="DeferredSpotLightPS"/>

            <state name="depthtest" value="false"/>
            <state name="depthwrite" value="false"/>

            <state name="blend" value="true"/>
            <state name="blendsrc" value="one"/>
            <state name="blenddst" value="one"/>

            <state name="cullmode" value="front"/>

            <state name="stencilTest" value="true"/>
            <state name="stencilFunc" value="equal"/>
            <state name="stencilTwoFunc" value="equal"/>
        </pass>
    </technique>
    <technique name="DeferredSpotLightShadow">
        <pass name="p0">
            <state name="inputlayout" value="POS3F"/>

            <state name="vertex" value="DeferredLighting2VS"/>
            <state name="fragment" value="DeferredSpotLightShadowPS"/>

            <state name="depthtest" value="false"/>
            <state name="depthwrite" value="false"/>

            <state name="blend" value="true"/>
            <state name="blendsrc" value="one"/>
            <state name="blenddst" value="one"/>

            <state name="cullmode" value="front"/>

            <state name="stencilTest" value="true"/>
            <state name="stencilFunc" value="equal"/>
            <state name="stencilTwoFunc" value="equal"/>
        </pass>
    </technique>
    <technique name="DeferredShadingOpaques">
        <pass name="p0">
            <state name="inputlayout" value="POS3F"/>

            <state name="vertex" value="DeferredScreenQuadVS"/>
            <state name="fragment" value="DeferredShadingOpaquesPS"/>

            <state name="cullmode" value="none"/>

            <state name="depthtest" value="false"/>
            <state name="depthwrite" value="false"/>
        </pass>
    </technique>
    <technique name="DeferredShadingTransparents">
        <pass name="p0">
            <state name="inputlayout" value="POS3F"/>

            <state name="vertex" value="DeferredScreenQuadVS"/>
            <state name="fragment" value="DeferredShadingTransparentsPS"/>

            <state name="cullmode" value="none"/>

            <state name="depthtest" value="false"/>
            <state name="depthwrite" value="false"/>

            <state name="blend" value="true"/>
            <state name="blendsrc" value="srcalpha"/>
            <state name="blenddst" value="invsrcalpha"/>
        </pass>
    </technique>
</effect>