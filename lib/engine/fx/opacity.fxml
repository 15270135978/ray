<?xml version='1.0'?>
<effect language="hlsl">
	<include name="sys:fx/Gbuffer.fxml"/>
	<include name="sys:fx/inputlayout.fxml"/>
	<parameter name="matModelViewProject" type="float4x4" semantic="matModelViewProject"/>
	<parameter name="matModelViewInverse" type="float4x4" semantic="matModelViewInverse"/>
	<parameter name="albedo" type="float3"/>
	<parameter name="albedoMap" type="texture2D"/>
	<parameter name="albedoMapFrom" type="int"/>
	<parameter name="albedoMapFilp" type="int"/>
	<parameter name="albedoMapLoopNum" type="float2"/>
	<parameter name="albedoSub" type="float3"/>
	<parameter name="albedoSubMap" type="texture2D"/>
	<parameter name="albedoSubMapFrom" type="int"/>
	<parameter name="albedoSubMapFilp" type="int"/>
	<parameter name="albedoSubMapLoopNum" type="float2"/>
	<parameter name="normalMap" type="texture2D"/>
	<parameter name="normalMapFrom" type="int"/>
	<parameter name="normalMapFilp" type="int"/>
	<parameter name="normalMapScale" type="float"/>
	<parameter name="normalMapLoopNum" type="float2"/>
	<parameter name="normalSubMap" type="texture2D"/>
	<parameter name="normalSubMapFrom" type="int"/>
	<parameter name="normalSubMapFilp" type="int"/>
	<parameter name="normalSubMapScale" type="float"/>
	<parameter name="normalSubMapLoopNum" type="float2"/>
	<parameter name="smoothness" type="float"/>
	<parameter name="smoothnessMap" type="texture2D"/>
	<parameter name="smoothnessMapFrom" type="int"/>
	<parameter name="smoothnessMapFilp" type="int"/>
	<parameter name="smoothnessMapSiwzzle" type="float4"/>
	<parameter name="smoothnessMapLoopNum" type="float2"/>
	<parameter name="metalness" type="float"/>
	<parameter name="metalnessMap" type="texture2D"/>
	<parameter name="metalnessMapFrom" type="int"/>
	<parameter name="metalnessMapFilp" type="int"/>
	<parameter name="metalnessMapSiwzzle" type="float4"/>
	<parameter name="metalnessMapLoopNum" type="float2"/>
	<parameter name="specular" type="float3"/>
	<parameter name="specularMap" type="texture2D"/>
	<parameter name="specularMapFrom" type="int"/>
	<parameter name="specularMapFilp" type="int"/>
	<parameter name="specularMapLoopNum" type="float2"/>
	<parameter name="occlusion" type="float"/>
	<parameter name="occlusionMap" type="texture2D"/>
	<parameter name="occlusionMapFrom" type="int"/>
	<parameter name="occlusionMapFilp" type="int"/>
	<parameter name="occlusionMapSiwzzle" type="float4"/>
	<parameter name="occlusionMapLoopNum" type="float2"/>
	<parameter name="emissive" type="float3"/>
	<parameter name="emissiveMap" type="texture2D"/>
	<parameter name="emissiveMapFrom" type="int"/>
	<parameter name="emissiveMapFilp" type="int"/>
	<parameter name="emissiveMapLoopNum" type="float2"/>
	<parameter name="customA" type="float"/>
	<parameter name="customAMap" type="texture2D"/>
	<parameter name="customAMapFrom" type="int"/>
	<parameter name="customAMapFilp" type="int"/>
	<parameter name="customASwizzle" type="float4"/>
	<parameter name="customALoopNum" type="float2"/>
	<parameter name="customB" type="float3"/>
	<parameter name="customBMap" type="texture2D"/>
	<parameter name="customBMapFrom" type="int"/>
	<parameter name="customBMapFilp" type="int"/>
	<parameter name="customBLoopNum" type="float2"/>
	<shader>
		<![CDATA[
			float3 DecodeNormalMap(Texture2D normal, float2 coord)
			{
				float3 bump;
				bump.xy = normal.Sample(PointClamp, coord).gr * 2.0 - 1.0;
				bump.z = sqrt(1.0 - bump.x * bump.x - bump.y * bump.y);
				return bump;
			}

			float3 GetAlbedo(float2 coord)
			{
				if (albedoMapFrom > 0 && albedoMapFrom < 6)
				{
					if (albedoMapFilp == 1)
						coord.x = 1 - coord.x;
					else if (albedoMapFilp == 2)
						coord.y = 1 - coord.y;
					else if (albedoMapFilp == 3)
						coord = 1 - coord;
					
					return srgb2linear(albedoMap.Sample(PointClamp, coord * albedoMapLoopNum).rgb) * albedo;
				}
				else
				{
					return albedo;
				}
			}

			float3 GetNormal(float3 normal, float3 tangent, float2 coord)
			{
				if (normalMapFrom > 0 && normalMapFrom < 6)
				{
					if (normalMapFilp == 1)
						coord.x = 1 - coord.x;
					else if (normalMapFilp == 2)
						coord.y = 1 - coord.y;
					else if (normalMapFilp == 3)
						coord = 1 - coord;
					
					float3 tangentNormal = normalMap.Sample(PointClamp, coord * normalMapLoopNum).rgb * 2 - 1;

					float3 N = normalize(normal);
					float3 T = normalize(tangent);
					float3 B = cross(N, T);

					float3x3 tbn = float3x3(T, B, N);
					float3 highNormal = mul(normalize(tangentNormal), tbn);
					return normalize(highNormal);
				}
				else
				{
					return normalize(normal);	
				}
			}
			
			float3 GetSpecular(float2 coord)
			{
				if (specularMapFrom > 0 && specularMapFrom < 6)
				{
					if (specularMapFilp == 1)
						coord.x = 1 - coord.x;
					else if (specularMapFilp == 2)
						coord.y = 1 - coord.y;
					else if (specularMapFilp == 3)
						coord = 1 - coord;
					
					return specularMap.Sample(PointClamp, coord * specularMapLoopNum).rgb * specular;
				}
				else
				{
					return specular;
				}
			}
			
			float GetSmoothness(float2 coord)
			{
				if (smoothnessMapFrom > 0 && smoothnessMapFrom < 6)
				{
					if (smoothnessMapFilp == 1)
						coord.x = 1 - coord.x;
					else if (smoothnessMapFilp == 2)
						coord.y = 1 - coord.y;
					else if (smoothnessMapFilp == 3)
						coord = 1 - coord;
					
					return dot(smoothnessMap.Sample(PointClamp, coord * smoothnessMapLoopNum), smoothnessMapSiwzzle) * smoothness;
				}
				else
				{
					return smoothness;
				}
			}

			float GetMetalness(float2 coord)
			{
				if (metalnessMapFrom > 0 && metalnessMapFrom < 6)
				{
					if (metalnessMapFilp == 1)
						coord.x = 1 - coord.x;
					else if (metalnessMapFilp == 2)
						coord.y = 1 - coord.y;
					else if (metalnessMapFilp == 3)
						coord = 1 - coord;
					
					return dot(metalnessMap.Sample(PointClamp, coord * metalnessMapLoopNum).r, metalnessMapSiwzzle) * metalness;
				}
				else
				{
					return metalness;
				}
			}
			
			float GetOcclusion(float2 coord)
			{
				if (occlusionMapFrom > 0 && occlusionMapFrom < 6)
				{
					if (occlusionMapFilp == 1)
						coord.x = 1 - coord.x;
					else if (occlusionMapFilp == 2)
						coord.y = 1 - coord.y;
					else if (occlusionMapFilp == 3)
						coord = 1 - coord;
					
					return dot(occlusionMap.Sample(PointClamp, coord * occlusionMapLoopNum).r, occlusionMapSiwzzle) * occlusion;
				}
				else
				{
					return occlusion;
				}
			}

			void DepthVS(
				in float4 Position : POSITION,
				out float4 oPosition : SV_Position)
			{
				oPosition = mul(matModelViewProject, Position);
			}

			void DepthPS()
			{
			}

			void ReflectiveShadowVS(
				in float4 Position : POSITION,
				in float4 TangentQuat : TANGENT,
				in float2 Texcoord : TEXCOORD,
				out float3 oNormal : TEXCOORD0,
				out float2 oTexcoord : TEXCOORD1,
				out float4 oPosition : SV_Position)
			{
				float3 Normal = QuaternionToNormal(TangentQuat * 2 - 1);

				oTexcoord = Texcoord;
				oNormal = mul(Normal, (float3x3)matModelViewInverse);
				oPosition = mul(matModelViewProject, Position);
			}

			GbufferParam ReflectiveShadowPS(
				in float3 normal : TEXCOORD0,
				in float2 coord : TEXCOORD1)
			{
				MaterialParam material;
				material.albedo = GetAlbedo(coord);
				material.normal = normalize(normal);
				material.specular = GetSpecular(coord);
				material.smoothness = GetSmoothness(coord);
				material.metalness = GetMetalness(coord);
				material.occlusion = GetOcclusion(coord);
				material.customB = customB;
				material.lightModel = LIGHTINGMODEL_NORMAL;

				return EncodeGbuffer(material);
			}

			void OpaqueVS(
				in float4 Position : POSITION,
				in float4 TangentQuat : TANGENT,
				in float2 Texcoord : TEXCOORD,
				out float3 oNormal : TEXCOORD0,
				out float3 oTangent : TEXCOORD1,
				out float2 oTexcoord : TEXCOORD2,
				out float4 oPosition : SV_Position)
			{
				TangentQuat = TangentQuat * 2 - 1;

				float3 Normal = QuaternionToNormal(TangentQuat);
				float3 Tangent = QuaternionToTangent(TangentQuat);

				oNormal = mul(Normal, (float3x3)matModelViewInverse);
				oTangent = mul(Tangent, (float3x3)matModelViewInverse);
				oTexcoord = Texcoord;
				oPosition = mul(matModelViewProject, Position);
			}

			GbufferParam OpaquePS(in float3 iNormal : TEXCOORD0, in float3 iTangent : TEXCOORD1, in float2 coord : TEXCOORD2)
			{
				MaterialParam material;
				material.albedo = GetAlbedo(coord);
				material.normal = GetNormal(iNormal, iTangent, coord);
				material.specular = GetSpecular(coord);
				material.smoothness = GetSmoothness(coord);
				material.metalness = GetMetalness(coord);
				material.occlusion = GetOcclusion(coord);

				material.customB = customB;
				material.lightModel = LIGHTINGMODEL_NORMAL;

				return EncodeGbuffer(material);
			}
		]]>
	</shader>
	<technique name="Shadow">
		<pass name="p0">
			<state name="inputlayout" value="POS3F_T4F_UV2F"/>
			<state name="vertex" value="DepthVS"/>
			<state name="fragment" value="DepthPS"/>
			<state name="primitive" value="triangle"/>
		</pass>
	</technique>
	<technique name="ReflectiveShadow">
		<pass name="p0">
			<state name="inputlayout" value="POS3F_T4F_UV2F"/>
			<state name="vertex" value="ReflectiveShadowVS"/>
			<state name="fragment" value="ReflectiveShadowPS"/>
			<state name="primitive" value="triangle"/>
			<state name="colormask0" value="rgba"/>
			<state name="colormask1" value="rgba"/>
		</pass>
	</technique>
	<technique name="Opaque">
		<pass name="p0">
			<state name="inputlayout" value="POS3F_T4F_UV2F"/>
			<state name="vertex" value="OpaqueVS"/>
			<state name="fragment" value="OpaquePS"/>
			<state name="primitive" value="triangle"/>
			<state name="colormask0" value="rgba"/>
			<state name="colormask1" value="rgba"/>
			<state name="stencilTest" value="true"/>
			<state name="stencilPass" value="replace"/>
			<state name="stencilTwoPass" value="replace"/>
		</pass>
	</technique>
</effect>