<?xml version='1.0'?>
<effect language="hlsl">
    <include name="sys:fx/Gbuffer.fxml"/>
    <include name="sys:fx/inputlayout.fxml"/>
    <parameter name="sssStep" type="float2"/>
    <parameter name="sssCorrection" type="float" />
    <parameter name="texSource" type="texture2D" />
    <parameter name="texDepthLinear" type="texture2D" semantic="DeferredDepthLinearMap"/>
    <parameter name="texMRT0" type="texture2D" semantic="DeferredGraphicMap" />
    <parameter name="texMRT1" type="texture2D" semantic="DeferredNormalMap" />
    <parameter name="eyeProjInfo" type="float4"/>
    <parameter name="lightColor" type="float3"/>
    <parameter name="lightEyePosition" type="float3" />
    <parameter name="shadowFactor" type="float4"/>
    <parameter name="shadowMap" type="texture2D" />
    <parameter name="shadowEye2LightView" type="float4"/>
    <parameter name="shadowEye2LightViewProject" type="float4x4"/>
    <shader name="vertex">
        <![CDATA[
        float3 SSSSTransmittance(float d)
        {
            float dd = -d * d;
            return float3(0.233f, 0.455f, 0.649f) * exp(dd / 0.0064f)
                 + float3(0.1f, 0.336f, 0.344f)   * exp(dd / 0.0484f)
                 + float3(0.118f, 0.198f, 0.0f)   * exp(dd / 0.187f)
                 + float3(0.113f, 0.007f, 0.007f) * exp(dd / 0.567f)
                 + float3(0.358f, 0.004f, 0.0f)   * exp(dd / 1.99f)
                 + float3(0.078f, 0.0f, 0.0f)     * exp(dd / 7.41f);
        }

        float4 SSSSTranslucency(float2 coord)
        {
            float4 MRT0 = texMRT0.Sample(PointClamp, coord);
            float4 MRT1 = texMRT1.Sample(PointClamp, coord);

            float3 N = restoreNormal(MRT1);
            float3 P = restorePosition(texDepthLinear, eyeProjInfo, coord);
            float3 L = normalize(P - lightEyePosition);
            float4 transmittance = 0;

            float irradiance = max(0.0, 0.3 + dot(N, L));
            if (irradiance > 0.0)
            {
                float4 proj = mul(float4(P, 1.0), shadowEye2LightViewProject);
                proj /= proj.w;
                proj = PosToCoord(proj);

                float d1 = linearDepth(shadowFactor.xyz, shadowMap.Sample(LinearClamp, proj.xy).r);
                float d2 = dot(float4(P, 1.0), shadowEye2LightView);
                float d = abs(d1 - d2);

                float3 diffuse = restoreDiffuse(MRT0);
                transmittance.xyz = SSSSTransmittance(d * shadowFactor.w) * irradiance * lightColor * diffuse;
            }

            return transmittance;
        }

        float4 SSSSBlurPS(float2 coord, texture2D texSource, texture2D texDepth, float correction, float2 step)
        {
            float w[6] = { 0.006f,   0.061f,   0.242f,  0.242f,  0.061f, 0.006f };
            float o[6] = {  -1.0f, -0.6667f, -0.3333f, 0.3333f, 0.6667f,   1.0f };

            float4 colorM = texSource.Sample(PointClamp, coord);
            float depthM = texDepth.Sample(PointClamp, coord).r;

            float2 finalStep = step / depthM;
            float4 colorBlurred = colorM * 0.382;

            [unroll]
            for (int i = 0; i < 6; i++)
            {
                float2 offset = coord +  o[i] * finalStep;
                float3 color = texSource.Sample(PointClamp, offset).rgb;
                float depth = texDepth.Sample(PointClamp, offset).r;
                float s = min(correction * abs(depthM - depth), 1);
                colorBlurred.rgb += w[i] * lerp(color, colorM.rgb, s);
            }

            return colorBlurred;
        }

        void PostProcessVS(
            in float4 Position : POSITION0,
            out float2 oTexcoord : TEXCOORD0,
            out float4 oPosition : SV_Position
            )
        {
            oPosition = Position;
            oTexcoord = PosToCoord(Position.xy);
        }

        float4 TranslucencyPS(in float2 coord : TEXCOORD0) : SV_Target
        {
            return SSSSTranslucency(coord);
        }

        float4 BlurPS(in float4 coord : TEXCOORD0) : SV_Target
        {
            return SSSSBlurPS(coord.xy, texSource, texDepthLinear, sssCorrection, sssStep);
        }
        ]]>
    </shader>
    <technique name="postprocess">
        <pass name="translucency">
            <state name="inputlayout" value="POS3F"/>

            <state name="vertex" value="PostProcessVS"/>
            <state name="fragment" value="TranslucencyPS"/>

            <state name="depthtest" value="false"/>
            <state name="depthwrite" value="false"/>

            <state name="cullmode" value="none"/>

            <state name="blend" value="true"/>
            <state name="blendsrc" value="one"/>
            <state name="blenddst" value="one"/>
        </pass>
        <pass name="blur">
            <state name="inputlayout" value="POS3F"/>

            <state name="vertex" value="PostProcessVS"/>
            <state name="fragment" value="BlurPS"/>

            <state name="cullmode" value="none" />

            <state name="depthtest" value="false"/>
            <state name="depthwrite" value="false"/>
        </pass>
    </technique>
</effect>