<?xml version='1.0'?>
<effect language="hlsl">
    <include name="sys:fx/GBuffer.fxml"/>
    <include name="sys:fx/lighting.fxml"/>
    <include name="sys:fx/inputlayout.fxml"/>
    <parameter name="texColor" type="texture2D"/>
    <parameter name="texNormal" type="texture2D"/>
    <parameter name="texDepthLinear" type="texture2D"/>
    <parameter name="texVPLBuffer" type="texture2D"/>
    <parameter name="texMRT0" type="texture2D"/>
    <parameter name="texMRT1" type="texture2D"/>
    <parameter name="lightOuterInner" type="float2"/>
    <parameter name="lightAttenuation" type="float3"/>
    <parameter name="VPLCountGridOffsetDelta" type="float4"/>
    <parameter name="matProjectInverse" type="float4x4" semantic="matProjectInverse"/>
    <parameter name="matModelViewProject" type="float4x4" semantic="matModelViewProject"/>
    <parameter name="shadowView2EyeView" type="float4x4"/>
    <shader>
        <![CDATA[
            void PostProcessVS(
                in float4 Position : POSITION,
                out float4 oTexcoord : TEXCOORD0,
                out float3 oViewdir : TEXCOORD1,
                out float4 oPosition : SV_Position)
            {
                oPosition = Position;
                oTexcoord = PosToCoord(Position);
                oViewdir  = -mul(matProjectInverse, Position).xyz;
            }

            float4 RSM2VPLsSpotPS(in float2 coord : TEXCOORD0, in float3 viewdir : TEXCOORD1) : SV_Target
            {
                float instanceID = floor(coord.x * VPLCountGridOffsetDelta.x);
                float i = VPLCountGridOffsetDelta.y * frac(instanceID / VPLCountGridOffsetDelta.y);
                float j = floor(instanceID / VPLCountGridOffsetDelta.y);
                float2 RSMcoord = VPLCountGridOffsetDelta.w * float2(i, j) + VPLCountGridOffsetDelta.zz;

                float4 MRT0 = texColor.Sample(PointClamp, RSMcoord);
                float4 MRT1 = texNormal.Sample(PointClamp, RSMcoord);

                float specular = restoreSpecular(MRT0);
                float shininess = restoreShininess(MRT1);

                float3 N = restoreNormal(MRT1);
                float3 V = normalize(viewdir);
                float3 P = restorePosition(texDepthLinear, RSMcoord, V);
                float3 albedo = restoreDiffuse(MRT0);

                if (coord.y < 1 / 3.0f)
                {
                    float4 lighting = 0;
                    float spot = spotLighting(float3(0,0,0), float3(0,0,1), lightOuterInner, P);
                    if (spot > 0)
                    {
                        float nl = -N.z;
                        if (nl > 0)
                        {
                            float atten = attenuationTerm(float3(0, 0, 0), P, lightAttenuation) * spot * nl;
                            lighting = float4(albedo * atten, specular);
                        }
                    }

                    return lighting;
                }
                else if (coord.y < 2 / 3.0f)
                {
                    float4 viewNormal = mul(shadowView2EyeView, float4(N, 0));
                    return float4(viewNormal.xyz, shininess);
                }
                else
                {
                    float4 viewPosition = mul(shadowView2EyeView, float4(P, 1));
                    viewPosition /= viewPosition.w;
                    return float4(viewPosition.xyz, length(P));
                }
            }

            float4 GatherIndirectPS(in float2 coord : TEXCOORD0, in float3 viewdir : TEXCOORD1) : SV_Target
            {
                float4 MRT0 = texMRT0.Sample(PointClamp, coord);
                float4 MRT1 = texMRT1.Sample(PointClamp, coord);

                float specular = restoreSpecular(MRT0);
                float shininess = restoreShininess(MRT1);

                float3 N = restoreNormal(MRT1);
                float3 V = normalize(viewdir);
                float3 P = restorePosition(texDepthLinear, coord, V);

                float4 lighting = 0;

                float offset = 1.0f / VPLCountGridOffsetDelta.x;

                for (float i = 0; i < 1.0; i+= offset)
                {
                    float4 flux = texVPLBuffer.Sample(PointClamp, float2(i, 0.0));
                    float4 normal = texVPLBuffer.Sample(PointClamp, float2(i, 0.5));
                    float4 position = texVPLBuffer.Sample(PointClamp, float2(i, 1.0));

                    float3 L = P - position.xyz;
                    L = normalize(L);

                    float length = distance(P, position.xyz);

                    float dstNL = max(0.0, dot(N, -L));
                    float srcNL = max(0.0, dot(normal.xyz, L));

                    float number = position.a * dstNL * srcNL;
                    float denom = VPLCountGridOffsetDelta.x * length + position.a;

                    lighting += flux * (number / denom);
                }

                return lighting;
            }
        ]]>
    </shader>
    <technique name="RSM2VPLsSpot">
        <pass name="p0">
            <state name="inputlayout" value="POS3F"/>
            <state name="vertex" value="PostProcessVS"/>
            <state name="fragment" value="RSM2VPLsSpotPS"/>

            <state name="cullmode" value="none"/>

            <state name="depthtest" value="false"/>
            <state name="depthwrite" value="false"/>
        </pass>
    </technique>
    <technique name="GatherIndirect">
        <pass name="p0">
            <state name="inputlayout" value="POS3F"/>
            <state name="vertex" value="PostProcessVS"/>
            <state name="fragment" value="GatherIndirectPS"/>

            <state name="cullmode" value="none"/>

            <state name="depthtest" value="false"/>
            <state name="depthwrite" value="false"/>

            <state name="blend" value="true"/>
            <state name="blendsrc" value="one"/>
            <state name="blenddst" value="one"/>
            <state name="blendalphasrc" value="one"/>
            <state name="blendalphadst" value="one"/>
        </pass>
    </technique>
</effect>