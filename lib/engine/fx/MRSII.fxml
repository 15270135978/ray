<?xml version='1.0'?>
<effect language="hlsl">
    <include name="sys:fx/GBuffer.fxml"/>
    <include name="sys:fx/lighting.fxml"/>
    <include name="sys:fx/inputlayout.fxml"/>
    <parameter name="texColor" type="texture2D"/>
    <parameter name="texNormal" type="texture2D"/>
    <parameter name="texDepthLinear" type="texture2D"/>
    <parameter name="texVPLBuffer" type="texture2D"/>
    <parameter name="texMRT0" type="texture2D"/>
    <parameter name="texMRT1" type="texture2D"/>
    <parameter name="lightOuterInner" type="float2"/>
    <parameter name="lightAttenuation" type="float3"/>
    <parameter name="VPLCountGridOffsetDelta" type="float4"/>
    <parameter name="matProjectInverse" type="float4x4" semantic="matProjectInverse"/>
    <parameter name="matModelViewProject" type="float4x4" semantic="matModelViewProject"/>
    <parameter name="shadowView2EyeView" type="float4x4"/>
    <shader>
        <![CDATA[
            void PostProcessVS(
                in float4 Position : POSITION,
                out float4 oTexcoord : TEXCOORD0,
                out float3 oViewdir : TEXCOORD1,
                out float4 oPosition : SV_Position)
            {
                oPosition = Position;
                oTexcoord = PosToCoord(Position);
                oViewdir  = -mul(matProjectInverse, Position).xyz;
            }

            float4 RSM2VPLsSpotPS(in float2 coord : TEXCOORD0, in float3 viewdir : TEXCOORD1) : SV_Target
            {
                float instanceID = floor(coord.x * VPLCountGridOffsetDelta.x);
                float i = VPLCountGridOffsetDelta.y * frac(instanceID / VPLCountGridOffsetDelta.y);
                float j = floor(instanceID / VPLCountGridOffsetDelta.y);
                float2 RSMcoord = VPLCountGridOffsetDelta.w * float2(i, j) + VPLCountGridOffsetDelta.zz;

                float4 MRT0 = texColor.Sample(PointClamp, RSMcoord);
                float4 MRT1 = texNormal.Sample(PointClamp, RSMcoord);

                float specular = restoreSpecular(MRT0);
                float shininess = restoreShininess(MRT1);

                float3 N = restoreNormal(MRT1);
                float3 V = normalize(viewdir);
                float3 P = restorePosition(texDepthLinear, RSMcoord, V);
                float3 albedo = restoreDiffuse(MRT0);

                if (coord.y < 1 / 3.0f)
                {
                    float4 lighting = 0;
                    float spot = spotLighting(float3(0,0,0), float3(0,0,1), lightOuterInner, P);
                    if (spot > 0)
                    {
                        float nl = -N.z;
                        if (nl > 0)
                        {
                            float atten = attenuationTerm(float3(0, 0, 0), P, lightAttenuation) * spot * nl;
                            lighting = float4(albedo * atten * shininess, atten);
                        }
                    }

                    return lighting;
                }
                else if (coord.y < 2 / 3.0f)
                {
                    float4 viewNormal = mul(shadowView2EyeView, float4(N, 0));
                    return float4(viewNormal.xyz, shininess);
                }
                else
                {
                    float4 viewPosition = mul(shadowView2EyeView, float4(P, 1));
                    viewPosition /= viewPosition.w;
                    return float4(viewPosition.xyz, specular);
                }
            }

           void GatherIndirectVS(
                in float4 Position : POSITION,
                in uint instanceID : SV_InstanceID,
                out float4 oTexcoord0 : TEXCOORD0,
                out float4 oTexcoord1 : TEXCOORD1,
                out float3 oViewdir : TEXCOORD2,
                out float4 oPosition : SV_Position)
            {
                float index = instanceID.x / VPLCountGridOffsetDelta.x;
                oPosition = Position;
                oTexcoord0 = float4(PosToCoord(Position.xy), index, 0.0);
                oTexcoord1 = float4(index, 0.5, index, 1.0);
                oViewdir  = -mul(matProjectInverse, Position).xyz;
            }

            float4 GatherIndirectPS(
                in float4 coord0 : TEXCOORD0,
                in float4 coord1 : TEXCOORD1,
                in float3 viewdir : TEXCOORD2) : SV_Target
            {
                float4 MRT0 = texMRT0.Sample(PointClamp, coord0.xy);
                float4 MRT1 = texMRT1.Sample(PointClamp, coord0.xy);

                float specular = restoreSpecular(MRT0);
                float shininess = restoreShininess(MRT1);

                float3 V = normalize(viewdir);
                float3 viewNormal = restoreNormal(MRT1);
                float3 viewPosition = restorePosition(texDepthLinear, coord0.xy, V);

                float4 lightColor = texVPLBuffer.Sample(PointClamp, coord0.zw);
                float4 lightNormal = texVPLBuffer.Sample(PointClamp, coord1.xy);
                float4 lightPosition = texVPLBuffer.Sample(PointClamp, coord1.zw);
                float3 lightDirection = normalize(lightPosition.xyz - viewPosition);

                float4 lighting = 0;

                float nl = max(0.0, dot(viewNormal, lightDirection));
                if (nl > 0.0f)
                {
                    lighting.rgb = brdfLambert(viewNormal, lightDirection, lightColor.xyz);
                    //lighting.a = brdfSpecular(viewNormal, lightDirection, V, shininess, specular * lightPosition.a);
                    lighting *= attenuationTerm(viewPosition, lightPosition.xyz, float3(1, 0, 1));
                }

                return lighting;
            }
        ]]>
    </shader>
    <technique name="RSM2VPLsSpot">
        <pass name="p0">
            <state name="inputlayout" value="POS3F"/>
            <state name="vertex" value="PostProcessVS"/>
            <state name="fragment" value="RSM2VPLsSpotPS"/>

            <state name="cullmode" value="none"/>

            <state name="depthtest" value="false"/>
            <state name="depthwrite" value="false"/>
        </pass>
    </technique>
    <technique name="GatherIndirect">
        <pass name="p0">
            <state name="inputlayout" value="POS3F"/>
            <state name="vertex" value="GatherIndirectVS"/>
            <state name="fragment" value="GatherIndirectPS"/>

            <state name="cullmode" value="none"/>

            <state name="depthtest" value="false"/>
            <state name="depthwrite" value="false"/>

            <state name="blend" value="true"/>
            <state name="blendsrc" value="one"/>
            <state name="blenddst" value="one"/>
            <state name="blendalphasrc" value="one"/>
            <state name="blendalphadst" value="one"/>
        </pass>
    </technique>
</effect>