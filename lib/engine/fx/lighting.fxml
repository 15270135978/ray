<?xml version="1.0"?>
<effect version="1270" language="hlsl">
    <include name="sys:fx/math.fxml"/>
    <include name="sys:fx/sampler.fxml"/>
    <shader>
        <![CDATA[
        float fresnelSchlick(float LdotH, float specular)
        {
            // https://seblagarde.wordpress.com/2012/06/03/spherical-gaussien-approximation-for-blinn-phong-phong-and-fresnel
            // pow(1.0 - LdotH, 5)
            // = exp2(-5.55473 * (LdotH * LdotH)- 6.98316 * LdotH))
            // = exp2((-5.55473 * LdotH - 6.98316) * LdotH)
            return specular + (1.0f - specular) * exp2((-5.55473 * LdotH - 6.98316) * LdotH);
        }

        float3 fresnelSchlick(float LdotH, float3 specular)
        {
            return specular + (1.0f - specular) * exp2((-5.55473 * LdotH - 6.98316) * LdotH);
        }

        float3 fresnelSchlick(float3 L, float3 H, float specular)
        {
            return fresnelSchlick(dot(L, H), specular);
        }

        float3 fresnelSchlick(float3 L, float3 H, float3 specular)
        {
            return fresnelSchlick(dot(L, H), specular);
        }

        float distributionTermBloackOpsII(float NdotH, float gloss)
        {
            // http://blog.selfshadow.com/publications/s2013-shading-course/lazarov/s2013_pbs_black_ops_2_slides_v2.pdf
            // https://seblagarde.wordpress.com/2012/06/03/spherical-gaussien-approximation-for-blinn-phong-phong-and-fresnel
            // pow(NdotH, smoothness)
            // = exp(-smoothness*(1-NdotH))
            // = exp2(smoothness / InvLog2 * NdotH - smoothness / InvLog2)
            float smoothness = pow(8192.0f, gloss);
            return ((smoothness + 2) / 8) * exp2(smoothness * InvLog2 * NdotH - smoothness * InvLog2);
        }

        float geometricShadowingSchlickSmithBlackOpsII(float gloss, float VdotH)
        {
            // http://blog.selfshadow.com/publications/s2013-shading-course/lazarov/s2013_pbs_black_ops_2_slides_v2.pdf
            float k = min(1.0f, gloss + 0.545f);
            return 1 / (k * VdotH * VdotH + 1 - k);
        }

        float3 brdfLambert(float3 N, float3 L, float3 diffuse)
        {
            return diffuse * max(0.0f, dot(N, L));
        }

        float brdfSpecular(float3 N, float3 L, float3 V, float gloss, float specular)
        {
            float nl = max(0.0, dot(N, L));
            if (nl > 0.0f)
            {
                float3 H = normalize(L + V);

                float nh = max(0.0f, dot(H, N));
                float lh = max(0.0f, dot(L, H));
                float vh = max(0.0f, dot(V, H));

                float D = distributionTermBloackOpsII(nh, gloss);
                float F = fresnelSchlick(lh, specular);
                float G = geometricShadowingSchlickSmithBlackOpsII(gloss, vh);

                return max(0.0f, D * F * G * nl);
            }

            return 0.0f;
        }

        float3 brdfEnvironmentDiffuse(float3 prefilteredColor)
        {
            return prefilteredColor;
        }

        float brdfEnvironmentSpecular(Texture2D texLUT, float3 N, float3 V, float gloss, float specular)
        {
            float NdotV = dot(N, V);
            if (NdotV > 0.0f)
            {
                float smoothness = pow(8192.0f, gloss);
                smoothness = log2(smoothness) / 13.0f;
                smoothness = max(0.5f / 16.0f, smoothness);

                float2 envBRDF = texLUT.Sample(PointClamp, float2(NdotV, 1.0f - smoothness)).rg;

                return (mad(specular, envBRDF.x, envBRDF.y));
            }

            return 0.0f;
        }

        float brdfEnvironmentSpecular(float3 N, float3 V, float gloss, float specular)
        {
            float NdotV = dot(N, V);

            float smoothness = pow(8192.0f, gloss);
            smoothness = log2(smoothness) / 13.0f;
            smoothness = max(0.5f / 16.0f, smoothness);

            float2 envBRDF;
            float4 tmp = ((float4(-4.996914762f, 7.253111161f, -1.963867075f, -0.170416225f) * smoothness
                + float4(8.993475061f, -15.42473953f, 4.712593001f, 0.448102365f)) * smoothness
                + float4(-4.928234727f, 10.95286522f, -3.852980973f, -0.389332014f)) * smoothness
                + float4(0.846124834f, -1.596815751f, 1.005729748f, 0.113484128f);
            envBRDF.x = (((tmp.x * NdotV + tmp.y) * NdotV + tmp.z) * NdotV) + tmp.w;
            tmp = ((float4(-0.684077741f, 1.316163916f, -0.70869252f, 0.073264505f) * smoothness
                + float4(0.719315865f, -1.384932814f, 0.775880046f, -0.105818706f)) * smoothness
                + float4(-0.101034049f, 0.18680998f, -0.117919199f, 0.030727381f)) * smoothness
                + float4(0.001922126f, 0.006697305f, -0.015741592f, 0.007229544f);
            envBRDF.y = (((tmp.x * NdotV + tmp.y) * NdotV + tmp.z) * NdotV) + tmp.w;
            envBRDF = saturate(envBRDF);

            return specular * envBRDF.x + envBRDF.y;
        }

        float attenuationTerm(float3 lightPosition, float3 P, float3 atten)
        {
            float3 v = lightPosition - P;
            float d2 = dot(v, v);
            float d = sqrt(d2);
            return 1 / dot(atten, float3(1, d, d2));
        }

        float spotLighting(float3 lightPosition, float3 lightDirection, float2 cosOuterInner, float3 pos)
        {
            // cosOuterInner is (cos_outer_cone, cos_inner_cone)
            float3 v = normalize(pos - lightPosition);
            float spotFactor = dot(v, lightDirection);
            return smoothstep(cosOuterInner.x, cosOuterInner.y, spotFactor);
        }

        float spotLighting(float3 lightPosition, float3 lightDirection, float2 cosOuterInner, float3 atten, float3 P)
        {
            float3 V = normalize(P - lightPosition);
            float spotFactor = dot(V, lightDirection);
            float attenuation = smoothstep(cosOuterInner.x, cosOuterInner.y, spotFactor);
            return attenuation * attenuationTerm(lightPosition, P, atten);
        }

        float pointLighting(float3 lightPosition, float3 world, float3 atten)
        {
            float distance = length(lightPosition - world);
            float attenuation = max(1.0f - (distance / atten.y), 0.0f);
            return attenuation;
        }

        float rimLighting(float3 lightColor, float LdotN, float NdotV, float LdotH)
        {
            float rim = saturate(1 - NdotV * 1.5);
            float rimPower = max(0,dot(NdotV, -LdotH));
            return rim * (1.0f - NdotV) * rimPower;
        }

        float skinBeckmann(float ndoth, float m)
        {
            float alpha = acos(ndoth);
            float ta = tan( alpha );
            float val = 1.0f / (m * m * pow(ndoth,4.0f)) * exp(-(ta * ta) / (m * m ));
            return val;
        }

        float shadowLighting(Texture2D shadowMap, float4x4 shadowEye2LightViewProject, float len, float4 shadowFactor, float3 viewPosition)
        {
            // shadowFactor.xyz is shadow clip constant
            // shadowFactor.w is shadow scale

            float4 proj = mul(float4(viewPosition, 1.0), shadowEye2LightViewProject);
            proj /= proj.w;
            proj.xy = PosToCoord(proj.xy);

            float d1 = linearDepth(shadowFactor.xyz, shadowMap.Sample(LinearClamp, proj.xy).r);
            float d2 = len;
            float d = exp(shadowFactor.w * (d1 - d2));
            float shadow = saturate(d);

            return shadow;
        }

        float shadowLighting(Texture2D shadowMap, float4x4 shadowEye2LightViewProject, float4 shadowEye2LightView, float4 shadowFactor, float3 viewPosition)
        {
            float len = dot(float4(viewPosition, 1.0), shadowEye2LightView);
            return shadowLighting(shadowMap, shadowEye2LightViewProject, len, shadowFactor, viewPosition);
        }
        ]]>
    </shader>
</effect>