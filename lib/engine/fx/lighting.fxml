<?xml version="1.0"?>
<effect version="1270" language="hlsl">
    <include name="sys:fx/math.fxml"/>
    <include name="sys:fx/sampler.fxml"/>
    <shader>
        <![CDATA[
        // https://seblagarde.wordpress.com/2012/06/03/spherical-gaussien-approximation-for-blinn-phong-phong-and-fresnel
        // http://blog.selfshadow.com/publications/s2013-shading-course/lazarov/s2013_pbs_black_ops_2_slides_v2.pdf
        // http://www.crytek.com/download/2014_03_25_CRYENGINE_GDC_Schultz.pdf
        // http://www.filmicworlds.com/2014/04/21/optimizing-ggx-shaders-with-dotlh/
        // http://ruh.li/GraphicsOrenNayar.html

        float SmoothnessToRoughness(float smoothness)
        {
            return (1.0f - smoothness) * (1.0f - smoothness);
        }

        float RoughnessToSmoothness(float roughness)
        {
            return 1.0f - sqrt(roughness);
        }

        float fresnelSchlick(float f0, float f9, float LdotH)
        {
            return lerp(f0, f9, exp2((-5.55473 * LdotH - 6.98316) * LdotH));
        }

        float3 fresnelSchlick(float3 f0, float f9, float LdotH)
        {
            return lerp(f0, f9, exp2((-5.55473 * LdotH - 6.98316) * LdotH));
        }

        float distributionTermBloackOpsII(float NdotH, float smoothness)
        {
            float alpha = pow(8192.0f, smoothness);
            return ((alpha + 2) / 8) * exp2(alpha * InvLog2 * NdotH - alpha * InvLog2);
        }

        float distributionTermRyse(float NdotH, float smoothness)
        {
            float alpha = pow(1 - smoothness * 0.7, 6);
            float alpha2 = alpha * alpha;
            float denom = NdotH * NdotH * (alpha2 - 1.0) + 1.0f;
            return alpha2 / (PIE * denom * denom);
        }

        float distributionTermGGX(float NdotH, float roughness)
        {
            float alpha2 = roughness * roughness;
            float spec = (alpha2 * NdotH - NdotH) * NdotH + 1;
            return alpha2 / (PIE * spec * spec);
        }

        float geometricShadowingBlackOpsII(float gloss, float vh)
        {
            float k = min(1.0f, gloss + 0.545f);
            return rcp(k * vh * vh + 1 - k);
        }

        float geometricShadowingRyse(float alpha, float LdotH)
        {
            float k = (0.8 + 0.5 * alpha) / 2.0f;
            float k2 = k * k;
            float k4 = k2 * k2;
            float invK2 = 1.0f - k4;
            return rcp(LdotH * LdotH * invK2 + k4);
        }

        float geometricShadowingGGX(float alpha, float LdotH)
        {
            float k = alpha / 2.0f;
            float k2 = k * k;
            float k4 = k2 * k2;
            float invK2 = 1.0f - k4;
            return rcp(LdotH * LdotH * invK2 + k4);
        }

        float LambertBRDF(float3 N, float3 L)
        {
            return saturate(dot(N, L));
        }

        float OrenNayarBRDF(float3 N, float3 L, float3 V, float roughness)
        {
            float sigma2 = roughness * roughness;

            float nl = dot(N, L);
            float nv = dot(N, V);
            float lv = dot(L, V);

            float s = lv - nl * nv;
            float t = s <= 0 ? 1 : max(max(nl, nv), 1e-6);

            float A = 1 - 0.5 * (sigma2 / (sigma2 + 0.57));
            float B = 0.45 * (sigma2 / (sigma2 + 0.09));

            return max(0, nl) * max(A + B * (s / t), 0);
        }

        float BurleyBRDF(float3 N, float3 L, float3 V, float roughness)
        {
            float3 H = normalize(V + L);

            float energyBias = 0.5 * roughness;
            float energyFactor = lerp(1, 1 / 1.51, roughness);

            float nl = saturate(dot(N, L));
            float vh = saturate(dot(V, H));
            float nv = abs(dot(N, V)) + 1e-5h;

            float fd90 = energyBias + 2.0 * vh * vh * roughness;

            float FL = fresnelSchlick(1, fd90, nl);
            float FV = fresnelSchlick(1, fd90, nv);

            return FL * FV * energyFactor * nl;
        }

        float DiffuseBRDF(float3 N, float3 L, float3 V, float gloss)
        {
            float roughness = SmoothnessToRoughness(gloss);
            return BurleyBRDF(N, L, V, roughness);
        }

        float3 TranslucencyBRDF(float3 N, float3 L, float3 transmittanceColor)
        {
            float w = lerp(0, 0.5, luminance(transmittanceColor));
            float wn = rcp((1 + w) * (1 + w));
            float nl = dot(N, L);
            float transmittance = saturate((-nl + w) * wn);
            float diffuse = saturate((nl + w) * wn);
            return diffuse + transmittanceColor * transmittance;
        }

        float3 SpecularBRDF(float3 N, float3 L, float3 V, float gloss, float3 f0)
        {
            float3 H = normalize(L + V);

            float roughness = SmoothnessToRoughness(gloss);
            float alpha = roughness * roughness;

            float nh = saturate(dot(H, N));
            float nl = saturate(dot(N, L));
            float lh = saturate(dot(L, H));
            float nv = abs(dot(N, V)) + 1e-5h;

            float D = distributionTermGGX(nh, alpha);
            float G = geometricShadowingGGX(alpha, lh);
            float3 F = fresnelSchlick(f0, saturate(dot(f0, 0.33333h) / 0.02h), lh);

            return D * F * G * nl;
        }

        float brdfEnvironmentEnvMip(float gloss, int numMip)
        {
            return lerp(numMip, 0, gloss);
        }

        float3 brdfEnvironmentEnvVec(float3 normal, float3 view)
        {
            return reflect(-view, normal);
        }

        float3 brdfEnvironmentDiffuse(float3 prefilteredColor, float3 diff)
        {
            return prefilteredColor * diff;
        }

        float3 brdfEnvironmentSpecularBlackOpsII(float3 prefilteredColor, float3 N, float3 V, float gloss, float3 specular)
        {
            float4 t = float4(1 / 0.96, 0.475, (0.0275 - 0.25 * 0.04) / 0.96, 0.25) * gloss;
            t += float4(0, 0, (0.015 - 0.75 * 0.04) / 0.96, 0.75);
            float a0 = t.x * min(t.y, exp2(-9.28 * dot(N, V))) + t.z;
            float a1 = t.w;
            return prefilteredColor * saturate(lerp(a0, a1, specular));
        }

        float3 brdfEnvironmentSpecularUnreal4(float3 prefilteredColor, float3 N, float3 V, float gloss, float3 specular)
        {
            float4 c0 = float4(-1, -0.0275, -0.572, 0.022);
            float4 c1 = float4(1, 0.0425, 1.04, -0.04);
            float4 r = (1 - gloss) * c0 + c1;
            float a004 = min(r.x * r.x, exp2(-9.28 * dot(N, V))) * r.x + r.y;
            float2 AB = float2(-1.04, 1.04) * a004 + r.zw;
            return prefilteredColor * (specular * AB.x + AB.y);
        }

        float3 brdfEnvironmentSpecularKlayge(float3 prefilteredColor, float3 N, float3 V, float gloss, float3 specular)
        {
            float NdotV = max(0, dot(N, V));
            gloss = max(0.5f / 16.0f, gloss);
            float2 envBRDF;
            float4 tmp = ((float4(-4.996914762f, 7.253111161f, -1.963867075f, -0.170416225f) * gloss
                + float4(8.993475061f, -15.42473953f, 4.712593001f, 0.448102365f)) * gloss
                + float4(-4.928234727f, 10.95286522f, -3.852980973f, -0.389332014f)) * gloss
                + float4(0.846124834f, -1.596815751f, 1.005729748f, 0.113484128f);
            envBRDF.x = (((tmp.x * NdotV + tmp.y) * NdotV + tmp.z) * NdotV) + tmp.w;
            tmp = ((float4(-0.684077741f, 1.316163916f, -0.70869252f, 0.073264505f) * gloss
                + float4(0.719315865f, -1.384932814f, 0.775880046f, -0.105818706f)) * gloss
                + float4(-0.101034049f, 0.18680998f, -0.117919199f, 0.030727381f)) * gloss
                + float4(0.001922126f, 0.006697305f, -0.015741592f, 0.007229544f);
            envBRDF.y = (((tmp.x * NdotV + tmp.y) * NdotV + tmp.z) * NdotV) + tmp.w;
            envBRDF = saturate(envBRDF);
            return prefilteredColor * (specular * envBRDF.x + envBRDF.y);
        }

        float3 brdfEnvironmentSpecular(float3 prefilteredColor, Texture2D texLUT, float3 N, float3 V, float gloss, float3 specular)
        {
            float NdotV = saturate(dot(N, V));
            float2 envBRDF = texLUT.Sample(PointClamp, float2(NdotV, gloss)).rg;
            return prefilteredColor * (specular * envBRDF.x + envBRDF.y);
        }

        float attenuationTerm(float3 lightPosition, float3 P, float3 atten)
        {
            float3 v = lightPosition - P;
            float d2 = dot(v, v);
            float d = sqrt(d2);
            return rcp(dot(atten, float3(1, d, d2)));
        }

        float spotLighting(float3 lightPosition, float3 lightDirection, float2 cosOuterInner, float3 atten, float3 pos)
        {
            // cosOuterInner is (cos_outer_cone, cos_inner_cone)
            float3 v = pos - lightPosition;
            float d2 = dot(v, v);
            float d = sqrt(d2);
            float spotFactor = dot(normalize(v), lightDirection);
            return smoothstep(cosOuterInner.x, cosOuterInner.y, spotFactor) * (spotFactor / dot(atten, float3(1, d, d2)));
        }

        float shadowLighting(Texture2D shadowMap, float4x4 shadowEye2LightViewProject, float4 shadowEye2LightView, float2 shadowFactor, float3 viewPosition)
        {
            // shadowFactor.x is shadow scale
            // shadowFactor.y is shadow bias

            float4 proj = mul(shadowEye2LightViewProject, float4(viewPosition, 1.0));
            proj /= proj.w;
            proj.xy = PosToCoord(proj.xy);

            float d1 = shadowMap.Sample(LinearClamp, proj.xy).r;
            float d2 = dot(shadowEye2LightView, float4(viewPosition, 1.0));
            float d = exp((shadowFactor.x * (d1 - d2) + shadowFactor.y));
            float shadow = saturate(d);

            return shadow;
        }

        float3 shadingLight(float3 albedo, float4 lighting)
        {
            return lighting.rgb * (albedo + lighting.a / (luminance(lighting.rgb) + 1e-6f));
        }
        ]]>
    </shader>
</effect>