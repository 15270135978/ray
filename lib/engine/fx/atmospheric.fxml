<?xml version="1.0"?>
<effect language="hlsl">
    <include name="sys:fx/inputlayout.fxml"/>
    <parameter name="matViewProject" semantic="matViewProject" type="float4x4"/>
    <parameter name="eyePosition" semantic="CameraPosition" type="float3"/>
    <parameter name="lightDirection" type="float3" />
    <parameter name="invWavelength" type="float3" />
    <parameter name="outerRadius" type="float" />
    <parameter name="outerRadius2" type="float" />
    <parameter name="innerRadius" type="float" />
    <parameter name="innerRadius2" type="float" />
    <parameter name="krESun" type="float" />
    <parameter name="kmESun" type="float" />
    <parameter name="kr4PI" type="float" />
    <parameter name="km4PI" type="float" />
    <parameter name="scaleFactor" type="float" />
    <parameter name="scaleDepth" type="float" />
    <parameter name="scaleOverScaleDepth" type="float" />
    <macro name="NUM_SAMPLES" type="int" value="4"/>
    <shader>
        <![CDATA[
        float scale(float angle)
        {
            float x = 1.0f - angle;
            return scaleDepth * exp(-0.00287f + x * (0.459f + x * (3.83f + x * (-6.80f + x * 5.25))));
        }

        void GroundVS(
            in float4 Position : POSITION0,
            out float3 c0 : TEXCOORD0,
            out float3 c1 : TEXCOORD1,
            out float4 oPosition : SV_Position)
        {
            Position = float4(Position.xyz * innerRadius,  1.0);
            Position.y -= innerRadius;

            float3 world = Position.xyz;
            world.y += innerRadius;

            float3 cameraPosition = eyePosition;
            cameraPosition.y += innerRadius;

            float3 ray = Position.xyz - eyePosition;
            float rayLength = length(ray);
            ray /= rayLength;

            float3 start = cameraPosition;

            float startDepth = 0;
            float startOffset = 0;

            float cameraLength2 = dot(cameraPosition, cameraPosition);
            if (cameraLength2 >= outerRadius2)
            {
                float B = 2.0 * dot(cameraPosition, ray);
                float C = cameraLength2 - outerRadius2;
                float det = max(0.0, B * B - 4.0 * C);
                float near = 0.5 * (-B - sqrt(det));

                rayLength -= near;

                start = start + ray * near;
                startDepth = exp((innerRadius - outerRadius) / scaleDepth);
            }
            else
            {
                startDepth = exp((innerRadius - length(cameraPosition)) / scaleDepth);
            }

            float cameraAngle = dot(-ray, world) / length(world);
            float cameraScale = scale(cameraAngle);
            float cameraOffset = startDepth * cameraScale;

            float lightAngle = dot(lightDirection, world) / length(world);
            float lightScale = scale(lightAngle);

            // Initialize the scattering loop variables
            float sampleLength = rayLength / NUM_SAMPLES;
            float scaledLength = sampleLength * scaleFactor;

            float3 sampleRay = ray * sampleLength;
            float3 samplePoint = start + sampleRay * 0.5f;

            // Now loop through the sample rays
            float3 sampleColor = float3(0, 0, 0);

            for(int i = 0; i < NUM_SAMPLES; i++)
            {
                float height = length(samplePoint);
                float depth = exp(scaleOverScaleDepth * (innerRadius - height));

                float scatter = depth * (lightScale + cameraScale) - cameraOffset;

                float3 attenuate = exp(-scatter * (invWavelength * kr4PI + km4PI));

                sampleColor += attenuate * (depth * scaledLength);
                samplePoint += sampleRay;
            }

            c0 = sampleColor * (invWavelength * krESun + kmESun);
            c1 = sampleColor * 0.25;

            oPosition = mul(Position, matViewProject);
        }

        float4 GroundPS(
            in float3 c0 : TEXCOORD0,
            in float3 c1 : TEXCOORD1) : SV_Target
        {
            return float4(c0 + c1, 1.0);
        }

        void SkyVS(
            in float4 Position : POSITION0,
            out float3 oViewDir : TEXCOORD0,
            out float4 oPosition : SV_Position)
        {
            Position.xyz *= outerRadius;
            Position.y -= innerRadius;
            oPosition = mul(Position, matViewProject);
            oViewDir = Position.xyz;
        }

        float4 SkyPS(in float3 viewdir : TEXCOORD) : SV_Target
        {
            float3 ray = viewdir - eyePosition;
            float rayLength = length(ray);
            ray /= rayLength;

            float3 cameraPosition = eyePosition + float3(0, innerRadius, 0);
            float3 start = cameraPosition;

            float startOffset = 0;
            float cameraLength2 = dot(cameraPosition, cameraPosition);

            if (cameraLength2 >= outerRadius2)
            {
                float B = 2.0 * dot(cameraPosition, ray);
                float C = cameraLength2 - outerRadius2;
                float det = max(0.0, B * B - 4.0 * C);
                float near = 0.5 * (-B - sqrt(det));
                rayLength -= near;
                start = start + ray * near;
                float startDepth = exp(-1.0 / scaleDepth);
                float startAngle = dot(ray, start) / outerRadius;
                startOffset = startDepth * scale(startAngle);
            }
            else
            {
                float startDepth = exp(scaleOverScaleDepth * (innerRadius - length(start)));
                float startAngle = dot(ray, start) / length(start);
                startOffset = startDepth * scale(startAngle);
            }

            float sampleLength = rayLength / NUM_SAMPLES;
            float scaledLength = sampleLength * scaleFactor;

            float3 sampleRay = ray * sampleLength;
            float3 samplePoint = start + sampleRay * 0.5f;

            float3 sampleColor = float3(0, 0, 0);

            for (int i = 0; i < NUM_SAMPLES; i++)
            {
                float height = length(samplePoint);
                float depth = exp(scaleOverScaleDepth * (innerRadius - height));

                float lightAngle = dot(lightDirection, samplePoint) / height;
                float cameraAngle = dot(ray, samplePoint) / height;

                float scatter = startOffset + depth * (scale(lightAngle) - scale(cameraAngle));

                float3 attenuate = exp(-scatter * (invWavelength * kr4PI + km4PI));

                sampleColor += attenuate * (depth * scaledLength);
                samplePoint += sampleRay;
            }

            float3 c0 = sampleColor * (invWavelength * krESun);
            float3 c1 = sampleColor * kmESun;

            float g = -0.990;
            float g2 = g * g;

            float angle = dot(lightDirection, normalize(-viewdir));
            float miePhase = 1.5f * ((1.0f - g2) / (2.0 + g2)) * (1.0 + angle * angle) / pow(1.0f + g2 - 2.0 * g * angle, 1.5f);

            return float4(c0 + c1 * miePhase, 1.0);
        }
        ]]>
    </shader>
    <technique name="ground">
        <pass name="p0">
            <state name="inputlayout" value="POS3F"/>
            <state name="vertex" value="GroundVS"/>
            <state name="fragment" value="GroundPS"/>
            <state name="cullmode" value="back" />
        </pass>
    </technique>
    <technique name="sky">
        <pass name="p0">
            <state name="inputlayout" value="POS3F"/>
            <state name="vertex" value="SkyVS"/>
            <state name="fragment" value="SkyPS"/>
            <state name="cullmode" value="front" />
        </pass>
    </technique>
</effect>